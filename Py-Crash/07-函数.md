# 函数

**函数是带名字的代码块,用于完成具体的工作。**

- 要执行函数定义的特定任务,可调用 该函数。
- 需要在程序中多次执行同一项任务时,无须反复编写完成该任务的代码,只需要调用执行该任务的函数,让 Python 运行其中的代码即可。

通过使用函数：程序编写、阅读、测试和修复起来都更加容易。

- 向函数传递信息的方式学习
- 如何编写主要任务是显示信息的函数
- 旨在处理数据并返回一个或一组值的函数
- 如何将函数存储在称为模块 的独立文件中,让主程序文件的组织更为有序

本章重要内容：

1. 定义函数
2. 传递实参
3. 返回值 return
   - 传递字典
4. 传递列表
   - 空表 append
5. 传递任意参数实参
   - 使用 \*args 和 \*\*kwargs

## 1. 定义函数

下面是一个打印问候语的简单函数,名为 greet_user() :

```py3
# greeter

def greet_user():
    """显示简单的问候语"""
    print("Hello!")

greet_user()
```

本例演示了最简单的函数结构:

1. 使用关键字 def 来告诉 Python,你要定义一个函数。

   - 这是函数定义 ,向 Python 指出了函数名,还可能在圆括号内指出函数为完成任务需要什么样的信息。
   - 在这里,函数名为 greet_user() ,它不需要任何信息就能完成工作,因此括号是空的(即便如此,括号也必不可少)。
   - 最后,定义以冒号结尾。

2. 紧跟在 def greet_user(): **后面的所有缩进行构成了函数体**。
3. 文本： """显示简单的问候语""" 是称为文档字符串 (docstring)的注释,描述了函数是做什么的。

   - 文档字符串用三引号括起,Python 使用它们来生成有关程序中函数的文档。

4. 代码行 print("Hello!") 是函数体内的唯一一行代码,因此 greet_user() 只做一项工作:打印 Hello! 。

- 要使用这个函数,可调用它。
- 函数调用 让 Python 执行函数的代码：
  - 要调用 函数, 可依次指定函数名以及用圆括号括起的必要信息,如 `greet_user()` 所示。
  - 由于这个函数不需要任何信息,调用它时只需输入 greet_user() 即可。和预期一样,它打印 Hello!

### 1.1. 向函数传递信息

- 函数定义的 def function() 括号内添加信息,以便函数能够处理。

```py3
def greet_user(username):
    """显示简单的问候语"""
    print(f"Hello, {username.title()}!")

greet_user('wendy')
# 代码greet_user('wendy') 调用函数greet_user() ,并向它提供执行函数调用print() 所需的信息。
# 这个函数接受你传递给它的名字,并向这个人发出问候
```

### 1.2. **实参和形参**

**重点来了，实参和形参：**

- 实参(Argument)：函数调用时传递给函数的值。

  - 例如：greet_user('wendy') 中的 **'wendy'**

- 形参(Parameter)：函数定义时定义的变量。
  - 例如：def greet_user(username): 中的 **username**

练习 8-1:消息 编写一个名为 display_message() 的函数,它打印一个句子,指出你在本章学的是什么。调用这个函数,确认显示的消息正确无误。

```py3
def display_message():
    """显示有关学习函数的信息"""
    print("I am learning functions")

display_message()
```

练习 8-2:喜欢的图书 编写一个名为 favorite_book() 的函数,其中包含一个名为 title 的形参。

这个函数打印一条消息,下面是一个例子

- One of my favorite books is Alice in Wonderland.

调用这个函数,并将一本图书的名称作为实参传递给它。

```py3
# Alice in Wonderland
def favorite_book(eatme):
    """显示最喜欢的书"""
    print(f"\nOne of my favorite books is {eatme.title()}.")

favorite_book('Alice in Wonderland')
```

## 2. 传递实参

函数定义中可能包含多个形参,因此函数调用中也可能包含多个实参。

向函数传递实参的方式很多：

1. 位置实参 ,这要求实参的顺序与形参的顺序相同;
2. 关键字实参 ,其中每个实参都由变量名和值组成;
3. 使用列表和字典。

### 2.1. 位置实参

调用函数时,Python 必须将函数调用中的每个实参都关联到函数定义中的一个形参。

为此,**最简单的关联方式是基于实参的顺序**。这种关联方式称为**位置实参**。

为明白其中的工作原理,来看一个显示宠物信息的函数。这个函数指出一个宠物属于哪种动物以及它叫什么名字,如下所示:

```py3
def describe_pet(animal_type,pet_name):
    """显示宠物信息"""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet('hamster', 'harry')
```

这个函数的定义表明,它需要一种动物类型和一个名字。

调用 describe_pet() 时,**需要按顺序提供一种动物类型和一个名字**。

例如,在刚才的函数调用中:

- 实参'hamster' 被赋给形参`animal_type`

- 实参'harry' 被赋给形参`pet_name`

在函数体内,使用了这两个形参来显示宠物的信息。

#### 2.1.1. 多次调用函数

可以根据需要调用函数任意次。

多次调用函数是一种效率极高的工作方式。

只需在函数中编写一次描述宠物的代码,然后每当需要描述新宠物时,都调用该函数并向它提供新宠物的信息。

即便描述宠物的代码增加到了 10 行,依然只需使用一行调用函数的代码,就可描述一个新宠物。
在函数中,可根据需要使用任意数量的位置实参,Python 将按顺序将函数调用中的实参关联到函数定义中相应的形参。

```py3
def describe_pet(animal_type,pet_name):
    """显示宠物信息"""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet('hamster', 'harry')
describe_pet('dog', 'willie')
```

与第一次调用时一样,Python 将实参'dog' 关联到形参 animal_type ,并将实参'willie' 关联到形参 pet_name。

#### 2.1.2. 位置实参的顺序很重要

**一定要注意顺序**：
使用位置实参来调用函数时,如果实参的顺序不正确,结果可能出乎意料:

```py3
def describe_pet(animal_type,pet_name):
    """显示宠物信息"""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet('harry','hamster')
```

### 2.2. 关键字实参

关键字实参 是**传递给函数的名称值对**。

- 一种**防呆设计**,防止函数调用时,提供了错误的实参
- 因为直接在实参中将名称和值关联起来,所以向函数传递实参时不会混淆
- 关键字实参让你无须考虑函数调用中的实参顺序,还清楚地指出了函数调用中各个值的用途。
- 使用关键字实参时,务必准确指定函数定义中的形参名。

```py3
def describe_pet(animal_type, pet_name):
     """显示宠物的信息。"""
     print(f"\nI have a {animal_type}.")
     print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet(animal_type='hamster', pet_name='harry')
```

自己看。

### 2.3. 默认值

编写函数时,可给每个形参指定默认值。

在调用函数中给形参提供了实参时, Python 将使用指定的实参值;

- **否则,将使用形参的默认值**

因此,给形参指定默认值后,可在函数调用中省略相应的实参。

使用默认值可简化函数调用,还可清楚地指出函数的典型用法。

```py3
# 例如调用函数describe_pet()时候，大多数描述的是小狗：

def describe_pet(pet_name, animal_type='dog'):
    """显示宠物的信息。"""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet(pet_name='willie')
```

这里修改了函数 describe_pet() 的定义,在其中给形参 animal_type 指定了**默认值'dog'** 。这样,调用这个函数时,如果没有给 animal_type 指定值, Python 就将把这个形参设置为**默认值'dog'**。

如果描述的不是小狗：可以使用**关键字实参**来指定它。

```py3
def describe_pet(pet_name, animal_type='dog'):
    """显示宠物的信息。"""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")

describe_pet(pet_name = 'harry' , animal_type = 'hamster')
```

等效的函数调用

鉴于可混合使用位置实参、关键字实参和默认值,通常有多种等效的函数调用方式。请看下面对函数 describe_pet() 的定义,其中给一个形参提供了默认值。

```py3
def describe_pet(pet_name, animal_type='dog'):
    """显示宠物的信息。"""
    print(f"\nI have a {animal_type}.")
    print(f"My {animal_type}'s name is {pet_name.title()}.")


# 一条名为willie 的小狗
describe_pet('willie')
describe_pet(pet_name='willie')

# 一只名为harry 的仓鼠
describe_pet('harry', 'hamster')
describe_pet(pet_name='harry', animal_type='hamster')
describe_pet(animal_type='hamster', pet_name='harry')
# 关键字实参能够确保参数指定的顺序
```

避免实参错误等：你开始使用函数后,如果遇到实参不匹配错误,不要大惊小怪。你提供的实参多于或少于函数完成工作所需的信息时,将出现实参不匹配错误。

练习 8-3:

T 恤 编写一个名为 make_shirt() 的函数,它接受一个尺码以及要印到 T 恤上的字样。这个函数应打印一个句子,概要地说明 T 恤的尺码和字样。

```py3
def make_shirt(size, word):
    print(f"\nThis a {size} size T-shirt.")
    print(f"\nIt shows '{word}' on it, cool!")

make_shirt('XL', 'Shit happens')
```

使用位置实参调用该函数来制作一件 T 恤,再使用关键字实参来调用这个函数。

```py3
def make_shirt(size='M', word='I love Python'):
    print(f"\nThis a {size} size T-shirt.")
    print(f"\nIt shows '{word}' on it, cool!")

make_shirt()
make_shirt('XL', 'Shit happens')
```

练习 8-4:

大号 T 恤 修改函数 make_shirt() ,使其在默认情况下制作一件印有“I love Python”字样的大号 T 恤。调用这个函数来制作:一件印有默认字样的大号 T 恤,一件印有默认字样的中号 T 恤,以及一件印有其他字样的 T 恤(尺码无关紧要)。

```py3
def make_shirt(size='XL', word='I love Python'):
    print(f"\nThis a {size} size T-shirt.")
    print(f"\nIt shows '{word}' on it, cool!")


sizes = ['XL', 'L', 'M', 'S']
words = ['I love Python', 'I love C++', 'I love Java', 'I love C#']

for size, word in zip(sizes, words):
    make_shirt(size, word)
```

练习 8-5:城市

编写一个名为 describe_city() 的函数,它接受一座城市的名字以及该城市所属的国家。这个函数应打印一个简单的句子,下面是一个例子。
Reykjavik is in Iceland.

给用于存储国家的形参指定默认值。为三座不同的城市调用这个函数,且其中至少有一座城市不属于默认国家。

```py3
def describe_city(city_name='Reykjavik', country_name='Iceland'):
    print(f"\n{city_name.title()} is in {country_name.title()}.")

cities = ['Reykjavik', 'London', 'Paris']
countries = ['Iceland', 'England', 'France']

for city, country in zip(cities, countries):
    describe_city(city, country)
```

## 3. 返回值 return

函数并非总是直接显示输出,它还可以处理一些数据,并返回一个或一组值，函数返回的值称为返回值 。

- 在函数中,可使用 return 语句将值返回到调用函数的代码行。返回值让你能够将程序的大部分繁重工作移到函数中去完成,从而简化主程序。

### 3.1. 打个样

```py3
# formatted_name

def get_formatted_name(first_name, last_name):
    """""返回整洁的姓名"""
    full_name = f"{first_name} {last_name}"
    return full_name.title()

musician = get_formatted_name('jimi', 'hendrix')
print(musician)
```

1. 函数 get_formatted_name() 的定义通过形参接受名和姓。

2. 它将姓和名合而为一,在中间加上一个空格,并将结果赋给变量 full_name。

3. 然后, 将 full_name 的值转换为首字母大写格式,并将结果返回到函数调用行。

4. 调用返回值的函数时,需要提供一个变量,以便将返回的值赋给它。在这里,将返回值赋给了变量 musician。输出为整洁的姓名

### 3.2. 可选实参

让实参变成可选的,这样使用函数的人就能只在必要时提供额外的信息。

```py3
def get_formatted_name(first_name,last_name,middle_name = ''):

    """""返回整洁的姓名"""
    if middle_name:
        full_name = f"{first_name} {middle_name} {last_name}"
    else:
        full_name = f"{first_name} {last_name}"
    return full_name.title()

musician = get_formatted_name('jimi', 'hendrix')
print(musician)

musician = get_formatted_name('john', 'hooker', 'lee')
print(musician)
```

- middle_name = '' 必须放在最后面啊

姓名是根据三个可能提供的部分创建的。

由于人都有名和姓,因此在函数定义中首先列出了这两个形参。中间名是可选的,因此**在函数定义中最后列出该形参**,并将其默认值设置为空字符串。

**在函数体中,检查是否提供了中间名。Python 将非空字符串解读为 True ,因此如果函数调用中提供了中间名,if middle_name 将为 True**。

如果提供了中间名,就将名、中间名和姓合并为姓名,再将其修改为首字母大写格式,并返回到函数调用行。

在函数调用行,将返回的值赋给变量 musician ,然后这个变量的值被打印出来。如果没有提供中间名,middle_name 将为空字符串,导致 if 测试未通过,进而执行 else 代码块:只使用名和姓来生成姓名,并将格式设置好的姓名返回给函数调用行。在函数调用行,将返回的值赋给变量 musician ,然后这个变量的值被打印出来。

调用这个函数时,如果只想指定名和姓,调用起来将非常简单。如果还要指定中间名,就必须确保它是最后一个实参,这样 Python 才能正确地将位置实参关联到形参。

### 3.3. 返回字典

函数可返回任何类型的值,包括列表和字典等较复杂的数据结构。

```py3
def build_person(first_name, last_name):
    """""返回一个字典,其中包含有关一个人的信息"""
    person = {'first': first_name, 'last': last_name}
    return person

musician = build_person('jimi', 'hendrix')

print(musician)
```

函数 build_person() 接受名和姓,并将这些值放到字典中。

存储 first_name 的值时,使用的键为'first' ,而存储 last_name 的值时,使用的键为'last' 。最后,返回表示人的整个字典。

在此基础上，下面的修改让你能存储年龄，注意自由形参还是放在了最后：

```py3
def build_person(first_name, last_name,age=None):
            ## age 默认没有，如果添加了再说
    """""返回一个字典,其中包含有关一个人的信息"""
    person = {'first': first_name, 'last': last_name}
    if age:
        person['age'] = age
    return person

musician = build_person('jimi', 'hendrix',age=30)
print(musician)

# 好像不太能用：

#      if type(age) == int:

#             person['age'] = age
#             return person
#         else:
#             print('Please enter a valid age')
```

在函数定义中,新增了一个可选形参 age ,并将其默认值设置为特殊值 None (表示变量没有值)。

- **可将 None 视为占位值**。在条件测试中,None 相当于 False 。

如果函数调用中包含形参 age 的值,这个值将被存储到字典中。在任何情况下,这个函数都会存储人的姓名,但可进行修改,使其同时存储有关人的其他信息。

### 3.4. 结合使用函数和 while 循环

下面将结合使用函数 get_formatted_name() 和 while 循环,以更正式的方式问候用户。

之前讲述的内容都是活的，要自己想明白灵活结合

```py3
def get_formatted_name(first_name, last_name):
    """返回整洁的姓名"""
    full_name = f"{first_name} {last_name}"
    return full_name.title()

while True:
    print("\nPlease tell me your name:")
    f_name = input("First name: ")
    l_name = input("Last name: ")

    formatted_name = get_formatted_name(f_name, l_name)
    print(f"\nHello, {formatted_name}!")
```

没错，我们还没有退出机制，所以我们要开搞了：

```py3
def formatted_name(first_name, last_name):
    """返回整洁的姓名"""
    full_name = f"{first_name} {last_name}"
    return full_name.title()

while True:
    print("\nPlease tell me your name:")
    print("(Enter 'q' at any time to quit)")

    f_name = input("Enter first name: ")
    if f_name == 'q':
        break

    l_name = input("Enter last name: ")
    if l_name == 'q':
        break
    # 不管是在哪里输入，都要弄出来退出机制
    formatted_name = formatted_name(f_name, l_name)
    print(f"\nHello, {formatted_name}!")
```

练习 8-6:城市名

编写一个名为 city_country() 的函数,它接受城市的名称及其所属的国家。

这个函数应返回一个格式类似于下面的字符串:

"Santiago, Chile"

至少使用三个城市国家对来调用这个函数,并打印它返回的值。

```py3
def city_country(city,country):
    """返回整洁的城市和国家"""
    locations = f"{city}, {country}"
    return locations.title()

while True:
    print("\nPlease tell me the city and country:")
    print("(Enter 'q' at any time to quit)")

    city = input("Enter the city: ")
    if city == 'q':
        break
        print(locations)

    country= input("Enter the country: ")
    if country == 'q':
        break
        print(locations)

    locations = city_country(city,country)
    print(f"\n{locations}")
```

练习 8-7:

专辑 编写一个名为 make_album() 的函数,它创建一个描述音乐专辑的字典。这个函数应接受歌手的名字和专辑名,并返回一个包含这两项信息的字典。使用这个函数创建三个表示不同专辑的字典,并打印每个返回的值,以核实字典正确地存储了专辑的信息。

```py3
def make_album(artist_name, album_title):
    """返回一个字典，其中包含有关专辑的信息"""
    album = {'artist': artist_name, 'title': album_title}

    return album

album = make_album('jimi', 'hendrix')
print(album)
```

给函数 make_album() 添加一个默认值为 None 的可选形参,以便存储专辑包含的歌曲数。如果调用这个函数时指定了歌曲数,就将该值添加到表示专辑的字典中。调用这个函数,并至少在一次调用中指定专辑包含的歌曲数。

```py3
def make_album(artist_name, album_title,track = None):
    """返回一个字典，其中包含有关专辑的信息"""
    album = {'artist_name' :artist_name,
                    'album_title': album_title}
    if track:
        album['track'] = track

    return album


cd_1 = make_album('jimi', 'hendrix')
print(cd_1)

cd_2 = make_album('zhang xueyou','wen bie', 10)
print(cd_2)

```

搞清楚哪里是 function，哪里是导入参数

练习 8-8:

用户的专辑 在为完成练习 8-7 编写的程序中,编写一个 while 循环,让用户输入专辑的歌手和名称。获取这些信息后,使用它们来调用函数 make_album() 并将创建的字典打印出来。在这个 while 循环中,务必提供退出途径。

```py3
def make_album(artist_name, album_title,track = None):
    """返回一个字典，其中包含有关专辑的信息"""
    album = {'artist_name' :artist_name,
                    'album_title': album_title}
    if track:
        album['track'] = track

    return album

while True:
    print("\nPlease enter the album info:")
    print("(Enter 'q' at any time to quit)")

    artist_name = input("Ente artist name: ")
    if artist_name == 'q':
        break

    album_title = input("Enter album title: ")
    if album_title == 'q':
        break

    track = input("Enter track number: ")
    if track == 'q':
        break

    make_album = make_album(artist_name, album_title,track)

    print(f"\n{make_album}, nice choice!")
```

## 4. 传递列表

将列表传递给函数后,函数就能直接访问其内容。使用函数来提高处理列表的效率。

假设有一个用户列表,我们要问候其中的每位用户。下面的示例将包含名字的列表传递给一个名为 greet_users() 的函数,这个函数问候列表中的每个人:

```py3
# greet_users
def greet_users(names):
    """向列表中的每位用户发出简单的问候"""
    for name in names:
        msg = f"hello,{name.title()}!"
        print(msg)

user_names = ['hannah', 'ty', 'margot']
greet_users(user_names)
```

### 4.1. 在函数中修改列表

将列表传递给函数后,函数就可对其进行修改。

在函数中对这个列表所做的任何修改都是永久性的,这让你能够高效地处理大量数据。

```py3
# 来看一家为用户提交的设计制作3D打印模型的公司。需要打印的设计存储在一个列表中,打印后将移到另一个列表中。下面是在不使用函数的情况下模拟这个过程的代码:
# 创建一个列表要包含打印的设计
unprinted_designs = ['phone case', 'robot pendant', 'dodecahedron']
completed_models = []

# 模拟每个打印设计
while unprinted_designs:
    current_design = unprinted_designs.pop()
    print(f"Printing model :{current_design}")
    completed_models.append(current_design)

# 显示打印好的所有模型
print("\nThe following models have been printed:")
for completed_model in completed_models:
    print(completed_model)
```

这个程序首先创建一个需要打印的设计列表,以及一个名为 completed_models 的空列表

每个设计打印后都将移到其中。只要列表 unprinted_designs 中还有设计,while 循环就模拟打印设计的过程:

从该列表末尾删除一个设计,将其赋给变量 current_design ,并显示一条消息指出正在打印当前的设计,然后将该设计加入到列表 completed_models 中。

循环结束后,显示已打印的所有设计

为重新组织这些代码,可编写两个函数

每个都做一件具体的工作，大部分代码与原来相同,只是效率更高。

第一个函数负责处理打印设计的工作,第二个概述打印了哪些设计

```py3
# 一 打印设计
def print_models(unprinted_designs, completed_models):
    """
    模拟打印每个设计，直到没有未打印的设计为止
    打印每个设计后，都将其移到列表completed_models 中
    """
    while unprinted_designs:
        current_design = unprinted_designs.pop()
        print(f"Printing model: {current_design}")
        completed_models.append(current_design)

#   二 概述打印了哪些设计
def show_completed_models(completed_models):
    """显示打印好的所有模型"""
    print(f"\nThe following models have been printed:")
    for completed_model in completed_models:
        print(completed_model)

unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
completed_models = []

print_models(unprinted_designs, completed_models)
show_completed_models(completed_models)
```

- 函数 print_models() 包含两个形参:一个需要打印的设计列表和一个打印好的模型列表。给定这两个列表,该函数模拟打印每个设计的过程:将设计逐个从未打印的设计列表中取出,并加入打印好的模型列表中。

- 函数 show_completed_models() ,它包含一个形参:打印好的模型列表。给定这个列表,函数 show_completed_models() 显示打印出来的每个模型的名称。

### 4.2. 为什么定义这个两个函数？

相比于没有使用函数的版本,这个程序更容易扩展和维护。

如果以后需要打印其他设计,只需再次调用 print_models() 即可。

如果发现需要对打印代码进行修改,只需修改这些代码一次,就能影响所有调用该函数的地方。

与必须分别修改程序的多个地方相比,这种修改的效率更高。

-代码耦合？

### 4.3. 禁止函数修改列表

向函数传递列表的副本而非原件：

- **function*name(list_name*[:])**

```py3
# 一 打印设计
def print_models(unprinted_designs, completed_models):
    """
    模拟打印每个设计，直到没有未打印的设计为止
    打印每个设计后，都将其移到列表completed_models 中
    """
    while unprinted_designs:
        current_design = unprinted_designs.pop()
        print(f"Printing model: {current_design}")
        completed_models.append(current_design)

#   二 概述打印了哪些设计
def show_completed_models(completed_models):
    """显示打印好的所有模型"""
    print(f"\nThe following models have been printed:")
    for completed_model in completed_models:
        print(completed_model)

unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
completed_models = []

print_models(unprinted_designs[:], completed_models)
show_completed_models(completed_models)
print(unprinted_designs)
```

练习 8-9:

消息 创建一个列表,其中包含一系列简短的文本消息。

将该列表传递给一个名为 show_messages() 的函数,这个函数会打印列表中的每条文本消息。

```py3
def show_msgs(msg_list):
    for msg in msg_list:
        print(msg)

this_is_a_new_list = ['hello', 'world', 'python']

show_msgs(this_is_a_new_list)
```

练习 8-10:
发送消息 在你为完成练习 8-9 而编写的程序中,编写一个名为 send_messages() 的函数,将每条消息都打印出来并移到一个名为 sent_messages 的列表中。

调用函数 send_messages() ,再将两个列表都打印出来,确认正确地移动了消息。

```py3
def send_msgs(msg_list,sent_msgs):
    """打印发送消息并将消息移动到sent_messages 列表"""
    while msg_list:
        current_msg = msg_list.pop()
        print(f"Sending messages : {current_msg}.")
        sent_msgs.append(current_msg)

def show_sent_msgs(sent_msgs):
    """打印发送消息"""
    print(f"\nThe following messages have been sent:")
    for sent_msg in sent_msgs:
        print(sent_msg)

this_is_a_new_list = ['hello', 'world', 'python']
this_is_an_empty_list = []
send_msgs(this_is_a_new_list,this_is_an_empty_list)
show_sent_msgs(this_is_an_empty_list)
```

```py3
def show_messages(unread_books,read_books):
    """列出每本待阅读书籍，直到没有未阅读的书籍
    打印阅读完成的书籍，移到列表read_books中
    """
    while unread_books:
        toread_book = unread_books.pop()
        print(f"To read books :{toread_book}")
        read_books.append(toread_book)

def send_messages(read_books):
    print('\n:These books have been read :')
    for book in read_books:
        print(book)

unread_books = ['python','java','c']
read_books = []

show_messages(unread_books,read_books)
send_messages(read_books)
```

练习 8-11:
消息归档 修改你为完成练习 8-10 而编写的程序,在调用函数 send_messages() 时,向它传递消息列表的副本。调用函数 send_messages() 后,将两个列表都打印出来,确认保留了原始列表中的消息。

```py3
def send_msgs(msg_list,sent_msgs):
    """打印发送消息并将消息移动到sent_messages 列表"""
    while msg_list:
        current_msg = msg_list.pop()
        print(f"Sending messages : {current_msg}.")
        sent_msgs.append(current_msg)

def show_sent_msgs(sent_msgs):
    """打印发送消息"""
    print(f"\nThe following messages have been sent:")
    for sent_msg in sent_msgs:
        print(sent_msg)

this_is_a_new_list = ['hello', 'world', 'python']
this_is_an_empty_list = []
send_msgs(this_is_a_new_list[:],this_is_an_empty_list)
show_sent_msgs(this_is_an_empty_list)
```

## 5. 传递任意参数实参 \*args \*\*kwargs

有时候,预先不知道函数需要接受多少个实参

Python 允许函数从调用语句中收集任意数量的实参。

以做 pizza 为例，需要接受很多配料，但是不知道顾客会点哪些配料。
使用形参 \*toppings，可以接受任意数量的实参。

```py3
# pizza *kwargs
def make_pizza(*toppings):
    """打印顾客点的配料"""
    print(f"\nMaking a pizza with the following toppings:")
    print(toppings)

make_pizza('pepperoni')
make_pizza('mushrooms','green peppers','extra cheese')
make_pizza('pepperoni','mushrooms','green peppers','extra cheese')
make_pizza('pepperoni','mushrooms','extra cheese','onions')
make_pizza('pepperoni','mushrooms','green peppers','extra cheese','onions','sausage')
```

好爽！

```py3
# 现在,可以将函数调用print() 替换为一个循环,遍历配料列表并对顾客点的比萨进行描述:
# pizza *kwargs
def make_pizza(*toppings):
    """打印顾客点的配料"""
    print(f"\nMaking a pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")

make_pizza('pepperoni')
make_pizza('mushrooms','green peppers','extra cheese')
make_pizza('pepperoni','mushrooms','green peppers','extra cheese')
make_pizza('pepperoni','mushrooms','extra cheese','onions')
make_pizza('pepperoni','mushrooms','green peppers','extra cheese','onions','sausage')
# 不管收到一个值还是三个值,这个函数都能妥善处理
```

### 5.1. 结合使用未知实参和任意数量实参

如果要让函数接受不同类型的实参,必须在函数定义中将接纳**任意数量实参的形参放在最后。**

**Python 先匹配位置实参和关键字实参**,再**将余下的实参都收集到最后一个形参**中。

```py3
def make_pizza(size, *toppings):
    """概述要制作的比萨。"""
    print(f"\nMaking a {size}-inch pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")

make_pizza(16, 'pepperoni')
make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
# 基于上述函数定义,Python将收到的第一个值赋给形参size ,并将其他所有值都存储在元组toppings 中。
```

### 5.2. 使用任意数量的关键字实参 \*\*kwargs

有时候,需要接受任意数量的实参,但预先不知道传递给函数的会是什么样的信息。

在这种情况下,**可将函数编写成能够接受任意数量的键值对**——调用语句**提供了多少就接受多少**。

```py3
# 一个这样的示例是创建用户简介:你知道将收到有关用户的信息,但不确定会是什么样的信息。
# 在下面的示例中,函数build_profile() 接受名和姓,还接受任意数量的关键字实参:
def build_profile(first, last, **user_info):
    """创建一个字典,其中包含我们知道的有关用户的一切"""
    user_info['first_name'] = first
    user_info['last_name'] = last
    return user_info

user_profile = build_profile('albert', 'einstein',
                             location='princeton',
                             field='physics')

print(user_profile)
```

```py3
def print_profile(first, last, **user_info):
    """创建一个字典,其中包含我们知道的有关用户的一切"""
    user_info['first_name'] = first
    user_info['last_name'] = last
    print(user_info)

print_profile('albert', 'einstein',
                             location='princeton',
                             field='physics')

print_profile('albert', 'einstein',
                             location='princeton',
                             field='physics',
                             age=56)
```

函数 build_profile() 的定义要求提供名和姓,同时允许根据需要提供任意数量的名称值对。

形参\***\*user_info** 中的**两个星号让 Python 创建一个名为 user_info 的空字典**,并将**收到的所有名称值对都放到这个字典中**。在这个函数中,可以像访问其他字典那样访问 user_info 中的名称值对。

在 build_profile() 的函数体内,将名和姓加入了字典 user_info 中，因为默认从用户那里收到这两项信息,而这两项信息没有放到这个字典中。

接下来,将字典 user_info 返回到函数调用行。

我们调用 build_profile() ,向它传递名('albert' )、姓('einstein' )和**两个键值对(location='princeton' 和 field='physics' )**,并将返回的 user_info 赋给变量 user_profile ,再打印该变量。在这里,返回的字典包含用户的名和姓,还有求学的地方和所学专业。调用这个函数时,不管额外提供多少个键值对,它都能正确地处理。

下面是一个典型错误：

- **SyntaxError: positional argument follows keyword argument**

告诉我们的是，**对于任意数量的关键字实参，必须在关键字实参之前放置位置实参。**

就是你得告诉 python, 你想接受的这个实参是什么类型的，必须要有个交代才好！

```py3
def print_profile(first, last, **user_info):
    """创建一个字典,其中包含我们知道的有关用户的一切"""
    user_info['first_name'] = first
    user_info['last_name'] = last
    print(user_info)

print_profile('tony', 'stark',
 location= 'new york',
                             job='ironman',
                             age=56,
                             'wakanda forever')
```

#### 5.2.1. 最后一点注意：你经常会看到形参名\*\*kwargs ,它用于收集任意数量的关键字实参

编写函数时,要能以各种方式混合使用位置实参、关键字实参和任意数量的实参。

知道这些实参类型大有裨益,因为阅读别人编写的代码时经常会见到它们。

#### 5.2.2. 不准确但是你可以大概知道的一点：\*args 是列表，\*\*kwargs 是字典

练习 8-12:

三明治 编写一个函数,它接受顾客要在三明治中添加的一系列食材。

这个函数只有一个形参(它收集函数调用中提供的所有食材),并打印一条消息,对顾客点的三明治进行概述。调用这个函数三次,每次都提供不同数量的实参。

```py3
def make_sandwich(gredients):
    print("\nThis is how your sandwich will be served:")
    for gredient in gredients:
        print(f"- {gredient}")

make_sandwich(['bread', 'tomato', 'cheese'])
```

练习 8-13:

用户简介 复制前面的程序 user_profile.py,在其中调用 build_profile() 来创建有关你的简介。调用这个函数时,指定你的名和姓,以及三个描述你的键值对。

```py3
def user_profile(first, last, **user_info):
    """创建一个字典,其中包含我们知道的有关用户的一切"""
    user_info['first_name'] = first.title()
    user_info['last_name'] = last.title()
    print(user_info)

user_profile('albert', 'einstein',
 location='princeton',
 field='physics',
 age=56)
```

练习 8-14:汽车

编写一个函数,将一辆汽车的信息存储在字典中。
这个函数总是接受制造商和型号,还接受任意数量的关键字实参。这样调用该函数:提供必不可少的信息,以及两个名称值对,如颜色和选装配件。

这个函数必须能够像下面这样进行调用:

car = make_car('subaru', 'outback', color='blue', tow_package=True)

打印返回的字典,确认正确地处理了所有的信息

```py3
def make_car(manufacturer, model, **car_info):
    """创建一个字典,其中包含我们知道的有关汽车的一切"""
    car_info['manufacturer'] = manufacturer.title()
    car_info['model'] = model.title()
    car_info = sorted(car_info.items(),reverse=True)
    return car_info

wang_car = make_car('audi', 'a6 crossroad', color = 'black',feature='hot hatchback')
tony_granny_car = make_car('honda','crv',color = 'white',year='2011')

print(wang_car)
print(tony_granny_car)
```

## 6. 将函数存储在模块中

使用**函数的优点之一是可将代码块与主程序分离**。
通过**给函数指定描述性名称**,可让**主程序容易理解得多**。
你还可以更进一步：

- 将函数存储在称为模块 的独立文件中,再将模块导入到主程序中。

- import 语句允许在当前运行的程序文件中使用模块中的代码。

通过将函数存储在独立的文件中：

- 可隐藏程序代码的细节,将**重点放在程序的高层逻辑**上。
- 在众多不同的程序中重用函数。
- 将函数存储在独立文件中后, **可与其他程序员共享这些文件而不是整个程序**。
- 知道如何导入函数还能让你使用其他程序员编写的函数库。

### 6.1. 导入整个模块

先编写模块：

```py3
# pizza.py
def make_pizza(size, *toppings):
    """概述要制作的披萨"""
    print(f"Making a {size} - inch pizza with the following toppings:")
    for topping in toppings:
        print(f"- {topping}")
```

接下来,**在 pizza.py 所在的目录中创建一个名为 making_pizzas.py 的文件**。

这个文件导入刚创建的模块,再调用 make_pizza() 两次:

```py3
import pizza

pizza.make_pizza(16, 'pepperoni')
pizza.make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese')
```

Python 读取这个文件时,代码行 import pizza 让 Python 打开文件 pizza.py,并将其中的所有函数都复制到这个程序中。

你看不到复制的代码,因为在这个程序即将运行时,Python 在幕后复制了这些代码。

你只需知道,在 making_pizzas.py 中,可使用 pizza.py 中定义的所有函数。

### 6.2. 导入特定的函数

import pandas as pd

对于前面的 making_pizzas.py 示例,如果只想导入要使用的函数,代码将类似于下面这样:

```py3
from pizza import make_pizza

make_pizza(16, 'pepperoni')
```

改名

```py3
from pizza import make_pizza as mp

mp(16, 'pepperoni')
```

还可以这样：

```py3
import pizza as p

p.make_pizza(16, 'pepperoni')
```

给模块指定别名的通用语法如下:

import **m**odule\_**n**ame as **mn**

导入所有模块： \*

```py3
from pizza import *

make_pizza(16, 'pepperoni')
```

最好别梭哈这个语法,因为它会导致你的程序更难以阅读。

## 7. 编写函数指南

牢记几个细节：

1. 应给函数指定描述性名称,且只在其中使用小写字母和下划线。
2. 描述性名称可帮助你和别人明白代码想要做什么。给模块命名时也应遵循上述约定。
3. 每个函数都应包含**简要地阐述其功能的注释**。

   - 该注释应紧跟在函数定义后面,并采用文档字符串格式。文档良好的函数让其他程序员只需阅读文档字符串中的描述就能够使用它。**他们完全可以相信代码如描述的那样运行,并且只要知道函数的名称、需要的实参以及返回值的类型,就能在自己的程序中使用它**。

4. 给形参指定默认值时,等号两边不要有空格:

```py3
def function_name(parameter_0, parameter_1='default_value'):
    """docstring"""
    pass
```

- 对于**函数调用中**的**关键字实参**,也应遵循这种约定:

```py3
function_name(parameter_0, parameter_1='default_value')
```

PEP 8 建议代码行的长度不要超过 79 字符

练习 8-15:打印模型

将示例 printing_models.py 中的函数放在一个名为 printing_functions.py 的文件中。在 printing_models.py 的开头编写一条 import 语句,并修改该文件以使用导入的函数。

```py3
import printing_functions as pf

unprinted_designs = ['iphone case', 'robot pendant', 'dodecahedron']
completed_models = []

pf.print_models(unprinted_designs, completed_models)
pf.show_completed_models(completed_models)

print(unprinted_designs)
```

## 8. 小结

在本章中,你学习了:

- 如何编写函数,以及如何传递实参,让函数能够访问完成其工作所需的信息;
- 如何使用位置实参和关键字实参,以及如何接受任意数量的实参;
- 显示输出的函数和返回值的函数;
- 如何将函数同列表、字典、if 语句和 while 循环结合起来使用;
- 如何将函数存储在称为模块 的独立文件中,让程序文件更简单、更易于理解;
- 函数编写指南,遵循这些指南可让程序始终结构良好,并对你和其他人来说易于阅读。

程序员的目标之一是:

- 编写简单的代码来完成任务,而函数有助于你实现这样的目标。它们让你编写好代码块并确定其能够正确运行后,就可置之不理。确定函数能够正确地完成其工作后,你就可以接着投身于下一个编码任务。

函数让你编写代码一次后,想重用它们多少次就重用多少次。需要运行函数中的代码时,只需编写一行函数调用代码,就可让函数完成其工作。需要修改函数的行为时,只需修改一个代码块,而所做的修改将影响调用这个函数的每个地方。

使用函数让程序更容易阅读,而良好的函数名概述了程序各个部分的作用。相对于阅读一系列的代码块,阅读一系列函数调用让你能够更快地明白程序的作用。

函数还让代码更容易测试和调试。如果程序使用一系列的函数来完成其任务,而其中的每个函数都完成一项具体的工作,测试和维护起来将容易得多:可编写分别调用每个函数的程序,并测试每个函数是否在它可能遇到的各种情形下都能正确地运行。经过这样的测试后你就能充满信心,深信每次调用这些函数时,它们都将正确地运行。


