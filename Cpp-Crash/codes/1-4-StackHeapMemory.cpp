#include <iostream>
using namespace std;

/*程序运行后：
栈内存Stack Memory (系统操作)
堆内存Heap Memory（手动操作）
 栈区 stack： 由编译器自动分配释放，存放函数的参数值，局部变量等
- 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

 堆区 heap：由程序员分配和释放，若不释放，程序结束时由操作系统回收
- 手动用new 进行开辟内存，用delete 释放内存
*/

//栈区数据注意事项:不要返回局部变量的地址
//栈区的数据由编译器管理开辟和释放

int *testStackFunc01(int b) { //     栈区
  b = 42;                     //行参数据例如b也会放在栈区
  int a = 10; //创建局部变量,存放在栈区,栈区的数据在函数执行完后自动释放
  return &a; // 就是手欠返回局部变量的地址,看来这里报错了，返回不了
             // 注意左边的报错，这是个蛮愚蠢的错误，我把局部变量的地址作为返回，但是局部数组变量是位于stack区的，函数结束后这个地址中的数据将失去意义;
             // static int a = 10; 可以解决报错但是返回值不对
}

int *testHeapFunc01() { //堆区
  int *a = new int(10); //创建新堆，增加整数10这个地址
  return a;
}

int main() {

  int *ptr01 = testStackFunc01(666); // 接收func函数的返回值
  // 第一次可以打印正确的数字是因为编译器做了保留，但是保留不会一直在：
  printf("%p\n", ptr01);
  // 第二次这个数据就不再保留了
  printf("%p\n", ptr01);
}
