# C++ 编程笔记 01

## 教材视频参考:

- 视频
  - CodeBeauty 10-hours
  - 原子之音
- 教材
  - cpp Crash
  - cpp primer
- 参考网站
  - W3C School
  - G4G

# 01 变量类型

# 变量

变量就是存储整型、浮点、双精度、字符串、布尔值、指针、数组等数据的有上限的容器。

- 变量的名称：内存位置的一个标记
- 变量的值：存储在变量中的东西(data)
- 存储的空间：存储数据的地方
- 变量的声明：声明类型和名称
- 变量的赋值：将数据赋给变量:
  
        int a 3;
        int a {3};
        




### 全局变量 局部变量

全局变量是在整个程序中有效的，局部变量是在函数中有效的。
Or:
- 全局变量： 在main外面定义的变量
- 局部变量： 在main内部定义的变量


### 静态变量

普通变量前面加`static`，属于静态变量
### 常量
- 字符串常量
- const 修饰的变量










### 常量
     一旦定义就不能修改

- 常量是一旦定义就不能修改的  `const float pi 3.14`
- 预定义(preprocessor directive) `#define PI 3.14`
    

## printf 格式化输出

printf 函数称为格式输出函数，其关键字最末一个字母 f 即为“格式”(format)之意。按照用户指定的格式（占位符），把指定的数据显示到屏幕上。



<div align = "center">
<div style="width:700px">

|        type        | examples | printf format specifiers |    etc     |
| :----------------: | :------: | :----------------------: | :--------: |
|       string       |          |            %s            | .to_cstr() |
|       short        |          |           %hd            |            |
|   unsigned short   |          |           %hu            |            |
|        int         |          |            %d            |            |
|    unsigned int    |          |            %u            |            |
|        long        |          |           %ld            |            |
|     long long      |          |           %lld           |            |
| unsigned long long |          |           %llu           |            |

![img](./img/formatSpecifiers.png)
![img](./img/formatSpecifiers2.png)
![img](./img/formatSpecifiers3.png)

</div>
</div>



The format specifier for a byte is %zd.
The format specifier %f displays a float with decimal digits, whereas %e displays the same number in scientific notation.

## 未完待续

### 关于%x的格式化输出：

中间是可以加数字表示间隔空行的，在二维数组中可以把元素中间间隔开，很美观。

```
printf("%1s %3f %5d\n", "hello", 3.14, 42);
//输出：
hello 3.140000    42
```
 可以看出，间隔增大




[关于输出函数详解](http://c.biancheng.net/cpp/html/33.html)

# 数据类型

# 介绍

- 静态类型
  - 有利于工具做静态分析，有利于性能优化，有利于代码可读性。
  - 动态类型一时爽，代码重构火葬场
  - 各有所长，保持敬畏

# 数据类型

C++中常见的数据类型.

操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么，比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等

<div align = "center">
<div style="width:800px">





|        类型        | 位（字节数）  |                                范围                                 |
| :----------------: | :-----------: | :-----------------------------------------------------------------: |
|        bool        |       1       |                               0 和 1                                |
|        char        |       1       |                      -128 到 127 或者 0 到 255                      |
|   unsigned char    |       1       |                              0 到 255                               |
|    signed char     |       1       |                             -128 到 127                             |
|        int         |       4       |                      -2147483648 到 214748364                       |
|    unsigned int    |       4       |                           0 到 4294967295                           |
|     signed int     |       4       |                      -2147483648 到 2147483647                      |
|     short int      |       2       |                           32768 到 32767                            |
| unsigned short int |       2       |                             0 到 65,535                             |
|  signed short int  |       2       |                           -32768 到 32767                           |
|      long int      |       8       |       -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807       |
|  signed long int   |       8       |       -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807       |
| unsigned long int  |       8       |                   0 到 18,446,744,073,709,551,615                   |
|       float        |       4       |   精度型占 4 个字节（32 位）内存空间，+/- 3.4e +/- 38 (~7 个数字)   |
|       double       |       8       | 双精度型占 8 个字节（64 位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |
|    long double     |      16       |  长双精度型 16 个字节（128 位）内存空间，可提供 18-19 位有效数字。  |
|      wchar_t       | 2 或 4 个字节 |                             1 个宽字符                              |


</div>
</div>

注意，各种类型的存储大小与系统位数有关，但目前通用的以 64 位系统为主。

> 计算结果超出数据类型元算所能表示的范围时产生溢出，溢出后像是过了半夜十二点从头开始

like:
The value of intMax is 2147483647
The value of intMax + 1 is -2147483648

# 带符号类型和无符号类型

有符号（signed）也就是该整型可以表示正数也可以表示负数，而无符号（unsigned）则表示该整数只能表示正数，不能表示负数。

- signed 存储符号是有代价的，代价就是存储空间中的一个比特位专门用来存储符号，这一位不能表示数值。

- 一般来说，同类型的 signed 能够存储的数的绝对值大小要小于 unsigned。

- 在我们定义变量时，如果没有显式声明是 signed 还是 unsigned，那么默认就是 signed。

# 数据类型的重要性

数据类型对程序非常重要，如果使用了错误的类型，程序可能会出错，或者程序可能会出现不可预料的结果。

所以在我们编程时，第一件事就是必须清楚，我们要使用的数据类型。



> 具体例子请看后文函数do-while循环中的希尔增量`increasement`例子。

- `increasement`是整型。

# 复合类型 指针 引用

## **指针\*是地址，引用&是别名**

## 引用 reference

引用为对象起了另外一个名字，**指向的是对象的地址，而不是对象本身**,同时，`&`被叫做取地址运算符


### 引用变量
- 它是引用的那个变量的alias简写，**改变这个引用变量会同时改变它引用的那个变量**
- 不会分配内存
- 在声明前必须被初始化
- 不需要解引用，比指针更好理解
- 工作起来就像是变量

坏处：
- 不如指针强大灵活

## 指针 pointer

指针(pointer)是“指向(point to)”另外一种类型的复合类型。

- **指针实现了对其他对象的间接访问**

- 指针本身就是一个对象，允许对指针赋值和拷贝，而且**在指针的生命周期内它可以先后指向几个不同的对象**。
- 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
- 指针可以被赋值为 NULL，表示指向一个空指针。
- 指针既包含了一个地址，也包含了一个类型。

关于指针：

1. 存储的是变量的内存地址
2. 为了访问数据必须先解决内存地址
3. 指针很有用，使用时注意也会引发危险
4. 指针的本质也是局部变量，放在栈上，指针保存的数据是放在堆区

## 想清楚： `*(&val) = ?`

是的，`*(&val) = val`，val 是一个变量，目前你这么理解是对的。

- `*`被叫做取值运算符，首先我们用了`&`去访问 val 的内存地址，然后用了`*`取到了这个内存地址的值，所以`*(&val)`是`val`的值。

## const 引用与指针

### Const-冻结： 可以冻结它后面的的指令所代表的含义

指针与const
- 指针两大操作空间：一个是重新指向，一个是变换当前值
    - `double const*`指向不可动,不能够变换指向
    - `const double*`指向的值不可以修改
    - `const double const*`也不能动，也不能变

引用与const
- 引用只有`const double&`相当于指针的`const double const*`，也不能动，也不能变







### 无类型指针`void *ptr`

`void *ptr`为无类型指针，指向任何类型的数据。
```c++
typedef struct LINKNODE {
  void *data; //数据域,void*为无类型指针，指向任何类型的数据
  struct LINKNODE *next; //指针域
} LinkNode;
```

### 回调函数与指针

- C++ 指针应用的精髓



```c++
int Find_LinkList(LinkList *list, LinkNode *data, COMPARENODE compare) {
  if (list == NULL) {
    return -1;
  }
  if (data == NULL) {
    return -1;
  }
  //创建辅助指针变量便利查找，头节点不看，直接next
  LinkNode *pCurrent = list->head.next;
  int index = 0; //初始化索引为0
  while (pCurrent != NULL) {
    //查找功能什么时候找到呢：需要做一个判断，引入比较函数指针
    if (compare(pCurrent, data) == 0) {
        break;

    }
    pCurrent = pCurrent->next;
    index++;
  }

  return index; //找到了就返回index的值，找不到就返回-1
};

```





## 引用指针小结后记

C++ 提供了两种指针运算符，一种是取地址运算符 &，一种是间接寻址运算符 \*。

指针是一个包含了另一个变量地址的变量，您可以把一个包含了另一个变量地址的变量说成是"指向"另一个变量。变量可以是任意的数据类型，包括对象、结构或者指针。
取地址运算符 &

& 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 &var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。

您可以把 & 运算符读作"取地址运算符"，这意味着，&var 读作"var 的地址"。
间接寻址运算符 \*

第二个运算符是间接寻址运算符 _，它是 & 运算符的补充。_ 是一元运算符，返回操作数所指定地址的变量的值。



从某种角度看，引用就是固定指向的指针
- 可以认为 引用就是`double *const` 

# 变量与内存分区模型

## 内存四区 代码区 全局区 栈区 堆区

四区的意义：不同区域存放的数据，赋予不同的生命周期，编程更灵活

### 程序运行前
 
 代码区： 存放函数体二进制代码，由操作系统进行管理
- 存放CPU执行的机器指令，代码区是共享、只读的
 
 全局区： 全局变量 静态变量 常量 都存放在此
- 上述变量常量存储在内存中不同的位置
	- 局部和全局不在一个区，常量区中存放 const修饰的全局常量  和 字符串常量
- 该区域数据在程序结束后由操作系统释放

### 程序运行后
 
 栈区 stack： 由编译器自动分配释放，存放函数的参数值，局部变量等
- 注意：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放
 
 堆区 heap：由程序员分配和释放，若不释放，程序结束时由操作系统回收
- 手动用new 进行开辟内存，用delete 释放内存

### 堆和栈的区别

1. 管理方式不同： 栈是由编译器自动申请和释放空间，堆是需要程序员手动申请和释放；
2. 空间大小不同： 栈的空间是有限的，在32位平台下，VC6下默认为1M，堆最大可以到4G；
3. 能否产生碎片： 栈和数据结构中的栈原理相同，在弹出一个元素之前，上一个已经弹出了，不会产生碎片，如果不停地调用malloc、free对造成内存碎片很多；
4. 生长方向不同： **堆生长方向是向上的，也就是向着内存地址增加的方向，栈刚好相反，向着内存减小的方向生长**。
5. 分配方式不同： 
   - 堆都是动态分配的，没有静态分配的堆。
   - 栈有静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。
6. 分配效率不同： 栈的效率比堆高很多。
   - 栈是机器系统提供的数据结构，计算机在底层提供栈的支持，分配专门的寄存器来存放栈的地址，压栈出栈都有相应的指令，因此比较快。堆是由库函数提供的，机制很复杂，库函数会按照一定的算法进行搜索内存，因此比较慢。


