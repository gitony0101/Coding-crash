# DSA-3 排序

> 从二叉树遍历理解排序：
> 
> [快速排序、归并排序与二叉树的关系](https://blog.csdn.net/weixin_45883310/article/details/111595541)

一组无序的数据元素调整为有序

- 我们需要的顺序

> 常见的基本排序算法有：
> 
> 插入排序，选择排序，冒泡排序，梳排序；
> 
> 高效的排序算法有：希尔排序，堆排序，快速排序，归并排序等。

- **快速排序和归并排序**是一定要掌握的，因为都用到了递归和分治的思想
- 其次是**堆排序**，属于堆数据结构部分的基础知识
- 其他排序从面试的角度讲，考察的概率很低

## 排序的稳定性

- 如果在序列中有两个数据元素 r[i]和 r[j]，它们的关键字 k[i] == k [j]，且在排序之
前，对象 r[i]排在 r[j]前面。如果在排序之后，对象 r[i]仍在 r[ j]前面，则称这个排序方 法是稳定的，否则称这个排序方法是不稳定的。

## 关键操作

- 比较：任意两数据元素比大小定次序
- 交换：按照结果和需要的次序交换位置

## 内排序和外排序

内排数据都在内存里面，外排数据需要在内存和外部存储之间多次交换

## 评定

- 时间性能：关键性能，区分好坏排序算法的主要因素差异体现在比较和交换的数量
- 辅助外部存储：为完成排序需要的额外存储空间
- 实现的复杂性

## 十大排序一览

## 冒泡排序



通过多次比较交换来实现排序，麻烦

冒泡排序的改进版

- 改进的是什么：如果已经排列有序了，就可以退出了，剩下的比较没有必要，**减少嵌套循环次数**
- 怎么改进：设置标志量`flag = 0/1`
- 如何改进：使用标志量来标识该层循环是否完成：
  - 未完成比较 `flag = 0`,那么此层循环开始
  - 已经完成比较 `flag =1 `，那么不用此层循环

## 选择排序

> 将无序的序列插入到有序的序列中，减少了交换次数

## 插入排序 

> 将无序的序列插入到有序的序列中
- **此消彼长**的动态思想
  - 消什么？无序的序列。长什么？有序的序列，通过循环壮大有序序列，吸收无序序列。
- 从局部循环到全部，二分法，这里已经开始了分组的雏形，隐含着分治的思想

> 什么时候用到插入排序？
> 
> 在序列基本有序效率高，或者数据序列元素比较少时候可以用
  - 希尔排序会有改进

## 下面开始高效的排序算法

## 希尔排序 [Shell Sort](https://zh.wikipedia.org/zh-my/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)

### 希尔排序是**插入排序改进版**，有跨度的排序，又叫“减少增量排序”
  - 有些时候高级算法就是在基础算法上得到了改进
> 希尔排序是**分组插入排序**，分组的方法由改变步长来实现
  - 为什么分：分完组以后，每一组元素数量少了，降低元素个数；先分组，对每一组分别进行插入排序，整体更趋近于元素数列基本有序
  - 怎么实现：跳着循环：新的跨度，从`j++`到`j += increasement`
    - **从累加1到累加增量**
  > 这个增量还在逐步减小：

- 怎么减：
  - `do-while`循环,让增量减小到1


思路：

1. 奇偶位元素分成两组，分别进行插入排序。分成**两个区间**
      - 分成多少个区间？ 经验来说**increasement / 3 + 1**
2. 两组排序过后，再将两组合并成一组，进行插入排序。分成**一个区间**


重点：

- `increasement`：跨度，增量，步长
- 利用增量来进行分组，并保持各组插入排序的一致性
  - 在本代码中，为了保持这种跨度，在相关的各级循环里面，都要有这种一致性的体现
- 增量的确定并无定论














## 快速排序

- 正如其名，目前排序最快的，快速排序，对冒泡排序的一种改进


### 基准数分治递归思想：快速排序就是个二叉树的前序遍历
- 分治法 + 挖坑填数
  - 分治法：以`pivot`中轴思想为抓手
  - 打头挖坑作为基准数`pivot`：
    - 从最右边开始找，找个比它小的放到左边的坑
    - 再从左边开始找，找个比它大的数，去填上一步右边的坑



> 第一次感受到了算法的强大，像是成千上万只蚂蚁啃大象的感觉

  ## 随机快速排序







- 要看

## 归并排序

### 归并排序就是个二叉树的后序遍历






- 拆分
- 计算机整数除法会取整
- 合并的过程里面包括比较复制的过程，也是排序的过程
  







## 堆排序 

利用完全二叉树顺序存储，将无序序列建成一个堆，优先队列，按照大小顶堆顺序弹出最大（最小元素）元素。将剩余的n-1个元素再调整成一个堆，重复执行，直到整个堆省一个元素


- 堆： 完全二叉树，根结点要么比子结点大（大顶堆），要么小（小顶堆）
  - 堆排序中完全二叉树的性质体现：维护堆的性质。堆排序就是一个调整堆的过程，目的是为了把最大或者最小的数放在根结点
  - 得到一个数组，就相当于给了一个完全二叉树
  - 大顶堆 （大根堆） **升序排列**
  - 小顶堆 （小根堆） **降序排列**





```plaintext

```
