# DSA-3 排序

一组无序的数据元素调整为有序

- 我们需要的顺序

> 常见的基本排序算法有：
> 
> 插入排序，选择排序，冒泡排序，梳排序；
> 
> 高效的排序算法有：希尔排序，堆排序，快速排序，归并排序等。

## 排序的稳定性

- 如果在序列中有两个数据元素 r[i]和 r[j]，它们的关键字 k[i] == k [j]，且在排序之
前，对象 r[i]排在 r[j]前面。如果在排序之后，对象 r[i]仍在 r[ j]前面，则称这个排序方 法是稳定的，否则称这个排序方法是不稳定的。

## 关键操作

- 比较：任意两数据元素比大小定次序
- 交换：按照结果和需要的次序交换位置

## 内排序和外排序

内排数据都在内存里面，外排数据需要在内存和外部存储之间多次交换

## 评定

- 时间性能：关键性能，区分好坏排序算法的主要因素差异体现在比较和交换的数量
- 辅助外部存储：为完成排序需要的额外存储空间
- 实现的复杂性

## 冒泡排序

## 选择排序

冒泡排序的改进版

## 插入排序 

> 将无序的序列插入到有序的序列中
- **此消彼长**的动态思想
  - 消什么？无序的序列。长什么？有序的序列，通过循环壮大有序序列，吸收无序序列。
- 从局部循环到全部，二分法

> 什么时候用到插入排序？
> 
> 在序列基本有序效率高，或者数据序列元素比较少时候可以用
  - 希尔排序会有改进

## 下面开始高效的排序算法

## 希尔排序 [Shell Sort](https://zh.wikipedia.org/zh-my/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)

### 希尔排序是插入排序改进版，有跨度的排序，又叫“减少增量排序”
  - 有些时候高级算法就是在基础算法上得到了改进
- 希尔排序是分组插入排序，分组的方法由改变步长来实现
  - 为什么分：分完组以后，每一组元素数量少了，降低元素个数；先分组，对每一组分别进行插入排序，整体更趋近于元素数列基本有序
  - 怎么实现：跳着循环：新的跨度，从`j++`到`j += increasement`
    - **从累加1到累加增量**
  > 这个增量还在逐步减小：

- 怎么减：
  - `do-while`循环,让增量减小到1


思路：

1. 奇偶位元素分成两组，分别进行插入排序。分成**两个区间**
      - 分成多少个区间？ 经验来说**increasement / 3 + 1**
2. 两组排序过后，再将两组合并成一组，进行插入排序。分成**一个区间**


重点：

- `increasement`：跨度，增量，步长
- 利用增量来进行分组，并保持各组插入排序的一致性
  - 在本代码中，为了保持这种跨度，在相关的各级循环里面，都要有这种一致性的体现
- 增量的确定并无定论












