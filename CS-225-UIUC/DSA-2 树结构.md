# DSA-2 树结构





定义：

- 由一个或多个$(n≥0)$结点组成的有限集合$T$，有且仅有一个结点称为根`root`；
- 当 $n>1$ 时，其余的结点分为 $m(m≥0)$个互不相交的有限集合 $T_1,T_2,⋯, T_m$。每个集合本身又是棵树，被称作这个根的子树。

术语：

- 根节点
- 叶子结点：终端没有后继的结点
- 结点：书的数据元素
- 结点的度：结点挂接子树的数，树的度：MAX{所有结点的度}
- 结点的层次：从根到该结点的层数（根节点算第一层），数的深度（或者高度）：MAX{所有结点的层次}
- 终端结点：度为0的结点，即叶子

还有：
- 分支结点
- 森林
- 有序树
- 无序树
- 双亲孩子兄弟堂兄弟祖先子孙，用到再说


## 二叉树

### 二叉树是你算法刷题的开始

> 递归、分治的思想在此体现

$n(n≥0)$个结点的有限集合，由一个根结点以及**两棵互不相交的**、分别称为左子树和右子树的二叉树组成.(可递归性显现)
- 每个节点最多只有两棵子树
- 左孩子右兄弟得到了二叉树，只有左右， 这样逻辑结构就是一对二  
	- 次序不能颠倒，很重要，孩子跟兄弟不一样  
	- 适合计算机？看起来很好处理
- 第$i$曾最多右$2^{i-1}(i>0)$个结点，深度为$k$的二叉树最多有$2^k-1(k>0)$个结点，满二叉树为此特例max
-

### **完全二叉树**：都有靠左的子结点,重点
- 重要，堆排序的灵魂
- 最后一层只缺少右边结点，其他都满
  - 增加叶子结点时候必须按照从左至右，缺一不可。
- 具有$n$个结点的完全二叉树的深度，必为 `int (log2n)+ 1` :)



### 完全二叉树实现顺序存储

> 对完全二叉树，若从上至下、从左至右编号，则编号为$i$的结点，其左孩子编号为$2i+1$，右孩子编号为$2i+2$，其父结点编号为$i/2$（$i=1$时为根除外）。使用此性质可以使用**完全二叉树实现顺序存储**（堆排序）。
























### 几个应用的思想








### 二叉树遍历  
- 指按某条搜索路线遍访每个结点且不重复(又称周游)。  
-  
	> 方法：约定对每个节点的查看都是**先左后右**
- 三种方法 
- **前序遍历DLR 中序遍历 LDR 后序遍历LRD**
	- `D`: data 根结点。`L`：左结点；`R`:右结点。  


> 排序中：快速排序就是个二叉树的前序遍历，归并排序就是个二叉树的后续遍历。
> 
> 只要是递归遍历，都可以有前序位置和后序位置，分别在递归前和递归后
> - 前序位置就是即将进入一个结点的时候
>  - 后序位置是离开一个结点的时候




> 多叉树没有中序遍历：
> - 左根右结构，遍历到跟结点，多个中间点无法确定到底哪个是根

### 求叶子结点的数目



### 求二叉树高度  



## 二叉搜索树

Binary Search Tree 二叉搜索树 特殊的二叉树  
- 左小右大：
  - 每个结点的左子树都比当前节点值小  
  - 每个结点的右子树都比当前节点值大  
> 由于左子树 < 父结点（中） < 右子树，这种特性使得中序遍历结果有序  



















```plaintext

```

## 一些思考

### 关于二叉树结构

二叉树结构可以认为是**二叉链表**
- 前中后序不只是一个链表，更是三个不同的时间点


二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。

### 关于递归思想：

- 递归,也就是每次调用自己就**相当于进入了新的循环**，这种特殊循环因为树结构的性质而有了天然的阈值，按照设定的要求，不断遍历自己。
 




