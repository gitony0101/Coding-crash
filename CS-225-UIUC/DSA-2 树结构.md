# DSA-2 树结构

叶子结点

**完全二叉树**：都有靠左的子结点
- 重要，堆排序的灵魂









数据结构的基础代码就是递归的故事







- 左孩子右兄弟得到了二叉树，只有左右， 这样逻辑结构就是一对二  
	- 次序不能颠倒，很重要，孩子跟兄弟不一样  
	- 适合计算机？看起来很好处理  
- 满二叉树  
- 完全二叉树：最后一层只缺少右边结点，其他都满  
- ### 二叉树遍历  
	- 指按某条搜索路线遍访每个结点且不重复(又称周游)。  
	-  
		> 方法：约定对每个节点的查看都是**先左后右**  

	- `D`: data 根结点。`L`：左结点；`R`:右结点。  
		- 三种方法 前序遍历DLR 中序遍历 LDR 后序遍历LRD  
			- ![image.png](../assets/image_1657626303536_0.png)  
			- 后序遍历：从局部到整体的一个统一结构，从小结构到大结构的有序统一，顺序统一  
			- ![image.png](../assets/image_1657705773035_0.png)  
				- 根据跟的位置区分三种方法，搭好框架一层一层写出来：举例  
					- ![image.png](../assets/image_1657705838862_0.png)  
					- 按照树结点划分块  
					- ![image.png](../assets/image_1657705897545_0.png)  
						- **先序遍历** 根左右，第一步先把顶层写出来：`ABC`  
							- 接下来很关键，先看B（也可以先看C），B有左结点D没有右结点，所以现在是`A   BD   C`；在看C这边，左右结点EF都有，那现在就写成`ABDCEF`；再往下一层看D（或者E），看到D左右结点EF都有，那就接着D后面写：`ABDGHCEF`,再看E有左结点I，最后结果就是：  
								- `ABDGHCEIF`  
						- **中序遍历**左根右，同样思想，第一步先把顶层写出来：`BAC`  
							- 同样方法往下看B（或者C）：B为根，有左结点D，加上后就是`DBAC`,看C这边左右结点EF都有，接着插入：`DBAECF`,接着往下看D（或者E或者F），左右结点GH都有，继续插入:`GDHBAECF`，同理看E，因为F没有子结点了，下面还有右结点I，所以最后结果是：  
								- `GDHBAEICF`  
						- **后序遍历**左右根，第一步写顶层:`BCA`  
							- 下面开始：`DBCA`>`DBEFCA`>`GHDBEFCA`>`GHDBIEFCA`  
	- ### 求二叉树高度  

	-  
	- ### 递归函数 
