# 第 9 章 类

**面向对象编程是最有效的软件编写方法之一。**

在面向对象编程中,**你编写表示现实世界中的事物和情景的类**,**并基于这些类来创建对象**。

**编写类时,你定义一大类对象都有的通用行为。**

基于类创建对象时,**每个对象都自动具备这种通用行为**,然后可根据需要赋予每个对象独特的个性。

根据**类来创建对象称为实例化** ,这让你能够**使用类的实例**。

理解面向对象编程有助于你像程序员那样看世界,还可以帮助你真正明白自己编写的代码:不仅是各行代码的作用,还有代码背后更宏大的概念。

## 创建和使用类

使用类几乎可以模拟任何东西。

### 创建小狗 dog 类

下面来编写一个表示小狗的简单类 Dog：

- 它表示的不是特定的小狗,而是任何小狗。
- 对于大多数宠物狗,它们都有名字和年龄,大多数小狗还会蹲下和打滚。
- 由于大多数小狗都具备上述两项信息(名字和年龄)和两种行为(蹲下和打滚),我们的 Dog 类将包含它们。

编写这个类后,我们将使用它来创建表示特定小狗的实例：

```python
# dog.py
class dog: # 这里直接冒号，并不定义形参
    """一个表示小狗的简单类"""
    def __init__(self, name, age):
        """初始化属性name和age"""
        self.name = name
        self.age = age

    def sit(self):
        """模拟小狗收到命令蹲下"""
        print(f"{self.name} is now sitting.")

    def roll_over(self):
        """模拟小狗收到命令打滚"""
        print(f"{self.name} rolled over!")
```

#### 逐个分析 dog 类

- `class dog:` 定义类
- `__init__()` 默认初始化

1. `class dog:` 用 class 关键字定义了一个类叫做 dog。**根据约定,在 Python 中,首字母大写的名称指的是类。**这个类定义中没有圆括号,因为要从空白创建这个类。`"""一个表示小狗的简单类"""` 此类文档字符串对这个 Dog 类进行了简单的描述。

2. 方法 `__init__()` 初始化了类的属性，**类中的函数称为方法**。**有关函数的一切都适用于方法**,就目前而言,唯一重要的差别是调用方法的方式。方法`__init__()` 是一个**特殊的并且是默认的**方法,**每当你根据 Dog 类创建新实例时,Python 都会自动运行它**。这个方法的名称中,**开头和末尾各有两个下划线,这是一种约定**,旨在避**免 Python 默认方法与普通方法发生名称冲突**。**务必确保`__init__()` 的两边都有两个下划线**,否则当你使用类来创建实例时,将不会自动调用这个方法,进而引发难以发现的错误。

   - 方法`__init__` 定义包含三个形参:`self 、name 和age`。
   - **形参 self 必不可少**,而且**必须位于其他形参的前面**，创建类的实例时,Python 将默认初始化`__init()__`并**自动默认调用 self**，我们通过`self`来传递类的属性，在此是 name 和 age。
   - 两个变量`self.name = name`和`self.age = age`都有前缀 self 。以 self 为前缀的变量**可供类中的所有方法使用**,可以通过类的任何实例来访问。self.name = name 获取与形参 name 相关联的值,并将其赋给变量 name ,然后该变量被关联到当前创建的实例。self.age = age 的作用与此类似。**像这样可通过实例访问的变量称为属性**。

3. 另外两个方法:sit() 和 roll_over() 。这些方法执行时不需要额外的信息,因此它们只有一个形参 self。

### 根据类创建实例

```python
# dog.py
class Dog:
    """一个表示小狗的简单类"""
    def __init__(self, name, age):
        """初始化属性name和age"""
        self.name = name
        self.age = age

    def sit(self):
        """模拟小狗收到命令蹲下"""
        print(f"{self.name} is now sitting.")

    def roll_over(self):
        """模拟小狗收到命令打滚"""
        print(f"{self.name} rolled over!")

my_dog =Dog('willie', 6)

print(f"My dog's name is {my_dog.name}.")
print(f"My dog is {my_dog.age} yeas old.")
```

书中 [**-snip--是省略前面的类余下的代码**](https://blog.csdn.net/qq_40490899/article/details/103705807)

这这里使用的是前一个示例中编写的 Dog 类:

1. `my_dog =Dog('willie', 6)`让 Python 创建一条名字为'Willie' 、年龄为 6 的小狗。
2. 遇到这行代码时,Python 使用实参'Willie' 和 6 调用 Dog 类的方法**init**() 。方法**init**() 创建一个表示特定小狗的实例,并使用提供的值来设置属性 name 和 age 。
3. 接下来,Python 返回一个表示这条小狗的实例,而我们将这个实例赋给了变量 my_dog 。

在这里,命名约定很有用:

- 通常可认为**首字母大写的名称(如 Dog )指的是类**,而**小写的名称(如 my_dog )指的是根据类创建的实例**。
  - 在 Python 中,**类的名称是全部大写的,而实例的名称是全部小写的**。

#### 句点表示法`class.XXX`访问属性和调用方法

要访问实例的属性,可使用句点表示法

```python
class Dog:
    """一个表示小狗的简单类"""
    def __init__(self, name, age):
        """初始化属性name和age"""
        self.name = name
        self.age = age

    def sit(self):
        """模拟小狗收到命令蹲下"""
        print(f"{self.name} is now sitting.")

    def roll_over(self):
        """模拟小狗收到命令打滚"""
        print(f"{self.name} rolled over!")

my_dog =Dog('willie', 6)

my_dog.name # 访问属性name
# 但是你要明白py这里运行后没有反应，因为在def  __init__() 中没有说要print()
my_dog.sit() # 访问方法sit(),这里按照方法 print(f"{self.name} is now sitting.")要求，会打印出来。
my_dog.roll_over() # 访问方法roll_over(),这里按照方法 print(f"{self.name} rolled over!")要求，会打印出来。
```

#### 创建多个实例

按需求根据类创建任意数量的实例， 向类 Dog 里面传递不同的实参，Dog 像是一个载体，汽车的一个底盘：

- 你想想，大众的 MQB 平台，可以按照不同的需求，创建不同的车型，比如迈腾和奥迪 A4，用的同款 MQB 平台，但是根本就是两个概念。

- 对，还有雪铁龙 C5 和标致 508。

举例：

```python
class Dog:
    """一个表示小狗的简单类"""
    def __init__(self, name, age,owner):
        """初始化属性name和age"""
        self.name = name
        self.age = age
        self.owner = owner

    def intro(self):
        """ 介绍小狗的主人"""
        print(f"This is {self.owner.title()}'s dog, its name is {self.name.title()} and its age is {self.age}.")

    def sit(self):
        """模拟小狗收到命令蹲下"""
        print(f"{self.name.title()} is now sitting.")

    def roll_over(self):
        """模拟小狗收到命令打滚"""
        print(f"{self.name.title()} rolled over!")


john_dog =Dog('willie', 6, 'john')
mike_dog = Dog('trump', 7, 'mike')

john_dog.intro()
john_dog.sit()

mike_dog.intro()
mike_dog.roll_over()
```

[练习 9-1:餐馆](https://blog.csdn.net/weixin_43096078/article/details/103784928)

创建一个名为 Restaurant 的类,为其方法**init**() 设置属性 restaurant_name 和 cuisine_type 。创建一个名为 describe_restaurant() 的方法和一个名为 open_restaurant() 的方法,前者打印前述两项信息,而后者打印一条消息,指出餐馆正在营业。
根据这个类创建一个名为 restaurant 的实例,分别打印其两个属性,再调用前述两个方法。

练习 9-2:三家餐馆 根据为完成练习 9-1 而编写的类创建三个实例,并对每个实例调用方法 describe_restaurant() 。

- **此例错误**

```python
class Restaurant(self,restaurant_name, cuisine_type):
    """一个表示餐馆的简单类"""
    def __init__(self, restaurant_name, cuisine_type):
        """"初始化属性restaurant_name 和cuisine_type"""
        self.restaurant_name = restaurant_name
        self.cuisine_type = cuisine_type

    def describe_restaurant(self):
        """打印餐馆的信息"""
        print(f"{self.restaurant_name.title()} is a {self.cuisine_type} restaurant.")

    def open_restaurant(self):
        """打印餐馆正在营业"""
        print(f"{self.restaurant_name.title()} is now open.")
```

你这里有一个经典的错误`class Restaurant(self,restaurant_name, cuisine_type):`定义类的第一行就上来设置形参，**这是不能的**，子类也不带这么玩的。

```python
class Restaurant:
    """一个表示餐馆的简单类"""
    def __init__(self, restaurant_name, cuisine_type):
        """"初始化属性restaurant_name 和cuisine_type"""
        self.restaurant_name = restaurant_name
        self.cuisine_type = cuisine_type

    def describe_restaurant(self):
        """打印餐馆的信息"""
        print(f"{self.restaurant_name.title()} is a {self.cuisine_type} restaurant.")

    def open_restaurant(self):
        """打印餐馆正在营业"""
        print(f"{self.restaurant_name.title()} is now open.")


restaurant_1 = Restaurant('pizza hut', 'pizza')
restaurant_2 = Restaurant('taco bell', 'taco')
restaurant_3 = Restaurant('burger king', 'burger')


restaurant_1.describe_restaurant()
restaurant_1.open_restaurant()
restaurant_2.describe_restaurant()
restaurant_2.open_restaurant()
restaurant_3.describe_restaurant()
restaurant_3.open_restaurant()
```

练习 9-3:用户

创建一个名为 User 的类,其中包含属性 first_name 和 last_name ,以及用户简介通常会存储的其他几个属性。

在类 User 中定义一个名为 describe_user() 的方法,用于打印用户信息摘要。

再定义一个名为 greet_user() 的方法,用于向用户发出个性化的问候。
创建多个表示不同用户的实例,并对每个实例调用上述两个方法。

```python
class User():
    """一个表示用户的简单类"""
    def __init__(self, first_name, last_name, age, favorite_language):
        """"初始化属性first_name 和last_name"""
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
        self.favorite_language = favorite_language

    def describe_user(self):
        """打印用户信息摘要"""
        print(f"\nName: {self.first_name.title()} {self.last_name.title()},\nAge: {self.age}\nFavorite coding language: {self.favorite_language}")

    def greet_user(self):
        """向用户发出个性化的问候"""
        print(f"\nHello, {self.first_name.title()} {self.last_name.title()}!")

mike = User('mike', 'daneil', '25', 'c')
lucy = User('lucy', 'daneil', '25', 'python')
lee = User('Lee', 'daneil', '25', 'java')
tom = User('Tom', 'daneil', '25', 'c++')

mike.describe_user()
mike.greet_user()

lucy.describe_user()
lucy.greet_user()

lee.describe_user()
lee.greet_user()

tom.describe_user()
tom.greet_user()
```

- 形参的位置特别重要：

之前我想在默认初始化**init**() 时候设置一个 sex，但是我发现 if 条件还不会加进去，我删掉了，却忘记了删除 def**init**()里面的
导致了后面的报错:

`TypeError: __init__() missing 1 required positional argument: 'favorite_language'`

这样的错误很经典也说明了在默认初始化属性的时候，`def __init__(self, first_name, last_name, age, s,favorite_language):`形参的位置特别重要，在下面 self.xxx 中的 xxx 也要从名称和顺序上一一对应。

## 使用类和实例

可使用类来模拟现实世界中的很多情景。

类编写好后,你的大部分时间将花在根据类创建的实例上。

你需要执行的一个重要任务是**修改实例的属性**：**可以直接修改实例的属性,也可以编写方法以特定的方式进行修改**。

### Car 类

```python
# 下面来编写一个表示汽车的类。它存储了有关汽车的信息,还有一个汇总这些信息的方法: car.py
class Car:
    """一次模拟汽车的简单类"""
    def __init__(self,make,model,year):
        """初始化描述汽车的属性"""
        self.make = make
        self.model = model
        self.year = year

    def get_discriptive_name(self):
        """返回整洁的描述性信息。"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()


my_new_car = Car('Audi','a4','2019')
print(my_new_car.get_discriptive_name())
```

- `__init()__` 默认初始化，self 打头引领了 make、model、year 三个初始化形参

- `get_discriptive_name(self)`方法引用 self 里面的三个形参

### 赋予、修改属性默认值

在默认初始化`__init__`里面制定默认值

```python
# 加入汽车里程表默认值
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车属性"""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0 # 设置里程表读数，默认为零
        # 有意思，这个odometer_reading 没有出现在def ___init__()括号的形参里面

    def get_discriptive_name(self):
        """返回整洁的描述性信息。"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        """打印一条汽车里程信息"""
        print(f"This car has {self.odometer_reading} miles on it.")

my_new_car = Car('Audi', 'a4',2019)
print(my_new_car.get_discriptive_name())
my_new_car.read_odometer()
```

#### 直接修改属性的值

```python
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车属性"""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_discriptive_name(self):
        """返回整洁的描述性信息。"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        """打印一条汽车里程信息"""
        print(f"This car has {self.odometer_reading} miles on it.")

my_new_car = Car('Audi', 'a4',2019)
print(my_new_car.get_discriptive_name())

#############直接看这里###################
my_new_car.odometer_reading = 23 # 直接赋值23
my_new_car.read_odometer()
```

#### 通过 def 方法修改属性的值

如果有方法能替你更新属性,将大有裨益。

这样就无须直接访问属性,而可将值传递给方法,由它在**内部进行更新**。

下面演示`def update_odometer(self, mileage)`方法,看到没，括号里面 self 打头，需要修改的 mileage 在里面

```python
# update_odometer(self, mileage)
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车属性"""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_discriptive_name(self):
        """返回整洁的描述性信息。"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        """打印一条汽车里程信息"""
        print(f"This car has {self.odometer_reading} miles on it.")

    ############看这里，定义了新的方法，在类内部更新形参odometer_reading####################
    def update_odometer(self, mileage):
        """更新里程表读数"""
        self.odometer_reading = mileage

my_new_car = Car('Audi', 'a4',2019)
print(my_new_car.get_discriptive_name())

#############在这里展示效果###################
my_new_car.update_odometer(23)
my_new_car.read_odometer()
```

**注意：**

如果`def update_odometer(self):`里面不提 mileage 这个形参，你将获得如下报错：

`TypeError: update_odometer() takes 1 positional argument but 2 were given`

好好体会 self，mileage 形参，以及这两个形参的位置，说要两个就一定需要两个。

#### update_odometer(self, mileage) 扩展 1

**加入 if 条件**，禁止任何人将里程表读书回调

```python
# update_odometer(self, mileage)  ver2.0
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车属性"""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0 ### 注意这里是初始值

    def get_discriptive_name(self):
        """返回整洁的描述性信息。"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        """打印一条汽车里程信息"""
        print(f"This car has {self.odometer_reading} miles on it.")

    ############看这里，定义了新的方法，在类内部更新形参odometer_reading####################
    def update_odometer(self, mileage):
        """更新里程表读数，将里程表读书设置为指定值
        禁止将里程表读数回调
        """
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

my_new_car = Car('Audi', 'a4',2019)
my_new_car.update_odometer(23)
my_new_car.read_odometer()
```

#### 通过方法对属性进行递增： odometer 扩展 2

有时候需要将属性**值递增特定的量**,而不是将其设置为全新的值。

假设我们购买了一辆二手车,且从购买到登记期间增加了 XX 英里的里程。

下面的方法让我们能够传递这个增量,并相应地增大里程表读数:

```python
# update_odometer(self, mileage)  ver3.0
class Car:
    def __init__(self,make,model,year):
        """初始化描述汽车属性"""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_discriptive_name(self):
        """返回整洁的描述性信息。"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        """打印一条汽车里程信息"""
        print(f"This car has {self.odometer_reading} miles on it.")

    def update_odometer(self, mileage):
        """更新里程表读数，将里程表读书设置为指定值
        禁止将里程表读数回调
        """
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        """将里程表读数增加制定的量。"""
        self.odometer_reading += miles
        ## 调用increment_odometer() 并传入数值 ,以增加从购买到登记期间行驶里程。


my_used_car = Car('subaru', 'outback', 2015)
print(my_used_car.get_discriptive_name())

my_used_car.update_odometer(23500)
my_used_car.read_odometer()

my_used_car.increment_odometer(10000)
my_used_car.read_odometer()
```

**注意**：

你可以使用类似于上面的方法来控制用户修改属性值(如里程表读数)的方式,但能够访问程序的人都可以通过直接访问属性来将里程表修改为任何值。要确保安全,除了进行类似于前面的基本检查外,还需特别注意细节。

### 练习

练习 9-4:就餐人数

在为完成练习 9-1 而编写的程序中,添加一个名为 number_served 的属性,并将其默认值设置为 0。根据这个类创建一个名为 restaurant 的实例。打印有多少人在这家餐馆就餐过,然后修改这个值并再次打印它。

添加一个名为 set_number_served() 的方法,让你能够设置就餐人数。调用这个方法并向它传递一个值,然后再次打印这个值。
添加一个名为 increment_number_served() 的方法,让你能够将就餐人数递增。调用这个方法并向它传递一个这样的值:你认为这家餐馆每天可能接待的就餐人数。

```python
class Restaurant():
    """一个表示餐馆的简单类"""
    def __init__(self, restaurant_name, cuisine_type):
        """"初始化属性restaurant_name、cuisine_type"""
        self.restaurant_name = restaurant_name
        self.cuisine_type = cuisine_type
        self.number_served = 8

    def describe_restaurant(self):
        """打印餐馆的信息"""
        print(f"{self.restaurant_name.title()} is a {self.cuisine_type} restaurant.")

    def open_restaurant(self):
        """打印餐馆正在营业"""
        print(f"{self.restaurant_name.title()} is now open.")

    def set_number_served(self,people):
        """"设置就餐人数,禁止回调"""
        if people >= self.number_served:
            self.number_served = people
            print(f"Threre are {self.number_served} people served today.")
        elif people >= 101:
            print(f"Out of limit, we just can serve 100 people.")
        else:
            print(f"We can not sever under {self.number_served} people")

    def increment_people(self, new_people):
        """人数增量"""
        self.number_served += new_people


restaurant_1 = Restaurant('pizza hut', 'pizza')
restaurant_1.set_number_served(10)
restaurant_1.increment_people(100)
restaurant_1.set_number_served(1000)
```

- 默认初始化和最后传递给类的实参是一一对应的，一个也不多，一个也不少

def **init**(self, restaurant_name, cuisine_type)

restaurant_1 = Restaurant('pizza hut', 'pizza')

- number_served 前面要加上默认的初始化 self，这是局部的实参

```python
class Restaurant():
    def __init__(self,restaurant_name,cuisine_type):
            self.restaurant_name=restaurant_name
            self.cuisine_type=cuisine_type
            self.number_served=0

    def describe_restaurant(self):
        print(self.restaurant_name)
        print(self.cuisine_type)

    def open_restaurant(self):
        print('This restaurant is open.')

    def set_number_served(self,n):
        for x in range(1,5):
         self.number_served+=n
         print('Day'+str(x)+': '+str(self.number_served))

    def increment_number_served(self,n):
        self.number_served+=n
        return self.number_served

KFC=Restaurant('KFC','fast food')
KFC.describe_restaurant()
KFC.open_restaurant()
KFC.set_number_served(10)
```

练习 9-5:尝试登录次数

在为完成练习 9-3 而编写的 User 类中,添加一个名为 login_attempts 的属性。

编写一个名为 increment_login_attempts() 的方法,将属性 login_attempts 的值加 1。

再编写一个名为 reset_login_attempts() 的方法,将属性 login_attempts 的值重置为 0。

根据 User 类创建一个实例,再调用方法 increment_login_attempts() 多次。

打印属性 login_attempts 的值,确认它被正确地递增。然后,调用方法 reset_login_attempts() ,并再次打印属性 login_attempts 的值,确认它被重置为 0。

```python
class User():
    """一个表示用户的简单类"""
    def __init__(self, first_name, last_name, age, favorite_language):
        """"初始化属性first_name 和last_name"""
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
        self.favorite_language = favorite_language
        self.login_attempts = 0

    def describe_user(self):
        """打印用户信息摘要"""
        print(f"\nName: {self.first_name.title()} {self.last_name.title()},\nAge: {self.age}\nFavorite coding language: {self.favorite_language}")

    def greet_user(self):
        """向用户发出个性化的问候"""
        print(f"\nHello, {self.first_name.title()} {self.last_name.title()}!")

    def increment_login_attempts(self):
        """登录次数增加"""
        self.login_attempts += 1
        print(f"\nYou have {self.login_attempts} login attempts.")

    def reset_login_attempts(self):
        """重置登录次数"""
        self.login_attempts = 0
        print(f"\nYou have {self.login_attempts} login attempts.")

mike = User('mike', 'daneil', '25', 'c')

mike.describe_user()
mike.greet_user()
mike.increment_login_attempts()
mike.reset_login_attempts()
```

## 继承

编写类时,并非总是要从空白开始。如果要编写的类是另一个现成类的特殊版本, 可使用继承 。

**原有的类称为父类 ,而新类称为子类**。

一个类继承另一个类时,**将自动获得另一个类的所有属性和方法**，同时还可以定义自己的属性和方法。

### 子类的方法 **init**()

ElectricCar 类的一个简单版本,它具备 Car 类的所有功能:

```python
##############父类##################
class Car:
    """一次模拟汽车的简单尝试"""
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        print(f"This car has {self.odometer_reading} miles on it")

    def update_odometer(self, mileage):
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        self.odometer_reading += miles

########################子类########################################
class ElectricCar(Car):
        """电动汽车的独特之处"""

        def __init__(self,make,model,year):
            """初始化父类的属性"""
            super().__init__(make,model,year)

my_tesla = ElectricCar('tesla','model s',2020)
print(my_tesla.get_descriptive_name())
```

1. 创建父类代码 Car
2. 创建子类时,父类必须包含在当前文件中,且位于子类前面:
3. 定义**子类 ElectricCar**。定义子类时,必须在圆括号内指定父类的名称**class ElectricCar(Car):**。方法**init**() 接受创建 Car 实例所需的信息。
4. **super() 是一个特殊函数,让你能够调用父类的方法**。这行代码**让 Python 调用父类 Car 的方法**init**()** ,让 ElectricCar 实例包含这个方法中定义的所有属性。**父类也称为超类 (superclass),名称 super 由此而来。**

为测试继承能够正确地发挥作用,我们尝试创建一辆电动汽车,但提供的信息与创建普通汽车时相同。创建 ElectricCar 类的一个实例,并将其赋给变量 my_tesla 。这行代码调用 ElectricCar 类中定义的方法**init**() ,后者让 Python 调用父类 Car 中定义的方法**init**() 。我们提供了实参'tesla' 、'model s' 和 2019 。

#### 想想这个顺序

```python
class ElectricCar(Car):
        """电动汽车的独特之处"""
        def __init__(self,make,model,year):
            """初始化父类的属性"""
            super().__init__(make,model,year)
```

按照类的定义，其实我们新定义的子类也是类的一种，遵循类的方式：`def __init__(self,make,model,year):`先进性了默认初始化，紧接着用`super().__init__(make,model,year)`调用父类，也就是定义了之前默认初始化的参数方法从哪里来。

### 给子类定义属性和方法

**继承父类的属性之后**，你可以在**子类中定义新的属性和方法**。

给子类电动车加上电池的方法：

```python
##############父类##################
class Car:
    """一次模拟汽车的简单尝试"""
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        print(f"This car has {self.odometer_reading} miles on it")

    def update_odometer(self, mileage):
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        self.odometer_reading += miles

########################子类########################################
class ElectricCar(Car):

    def __init__(self,make,model,year):
        """初始化父类的属性"""
        super().__init__(make, model,year) # super 函数调用父类的方法
        """初始化电动汽车特有的属性battery size"""
        self.battery_size = 75

    def describe_battery(self):
        """打印一条描述电瓶容量的消息"""
        print(f"This car has a {self.battery_size}- KWh battery.")


my_tesla = ElectricCar('tesla','model s',2020)
print(my_tesla.get_descriptive_name())
my_tesla.describe_battery()
```

子类，还是 class，这里你之前错的很经典和 def 混淆了你

这个子类添加了新属性 self.battery_size ,并设置其初始值(75 )。根据 ElectricCar 类创建的所有实例都将包含该属性,**但所有 Car 实例都不包含它**。

另外还添加了一个名为 describe_battery() 的方法,打印有关电瓶的信息。调用这个方法时,将看到一条电动汽车特有的描述

### 重写父类的方法

使用代码模拟实物时,你可能会发现自己给**类添加的细节越来越多:属性和方法清单以及文件都越来越长**。

在**这种情况下,可能需要将类的一部分提取出来,作为一个独立的类**。可以将**大型类拆分成多个协同工作的小类**。

也就是说，我们把之前长长的一整坨代码拿出来分开弄，使用方便，看得更清楚。

例如,不断给 ElectricCar 类添加细节时,我们可能发现其中包含很多专门针对汽车电瓶的属性和方法。在这种情况下,**可将这些属性和方法提取出来,放到一个名为 Battery 的类中,并将一个 Battery 实例作为 ElectricCar 类的属性**

```python
##############父类##################
class Car:
    """一次模拟汽车的简单尝试"""
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        print(f"This car has {self.odometer_reading} miles on it")

    def update_odometer(self, mileage):
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        self.odometer_reading += miles
##############电瓶##################
class Battery:
    """一次模拟电动汽车电瓶的方法"""
    def __init__(self, battery_size=75):
        """初始化电瓶属性"""
        self.battery_size = battery_size

    def describe_battery(self):
        """打印一条描述电瓶容量的消息"""
        print(f"This car has a {self.battery_size} - kWH battery.")

##############子类##################
class ElectricCar(Car):
    """电动汽车特点"""
    def __init__(self,make,model,year):
        """初始化Car父类属性，然后初始化电动车特有属性"""
        super().__init__(make, model, year)
        self.battery = Battery() # 调用电瓶属性

my_tesla = ElectricCar('tesla','model s',2020)
my_tesla.battery.describe_battery()
```

- Battery 是定义的新类,它没有继承任何类，自带形参 battey_size
- 在子类 ElectricCa 中，添加了`self.battery`属性，并调用了 Battery 类方法，使用的时候为`my_tesla.battery.describe_battery()`
- 这看似做了很多额外的工作,**但是现在想多详细地描述电瓶都可以,且不会导致 ElectricCar 类混乱不堪**。下面再给 Battery 类添加一个方法,它根据电瓶容量报告汽车的续航里程:

```python
##############父类##################
class Car:
    """一次模拟汽车的简单尝试"""
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        print(f"This car has {self.odometer_reading} miles on it")

    def update_odometer(self, mileage):
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        self.odometer_reading += miles
##############电瓶类，并添加一个新方法显示电池续航里程##################
class Battery:
    """一次模拟电动汽车电瓶的方法"""
    def __init__(self, battery_size=75):
        """初始化电瓶属性"""
        self.battery_size = battery_size

    def describe_battery(self):
        """打印一条描述电瓶容量的消息"""
        print(f"This car has a {self.battery_size} - kWH battery.")

    def get_range(self):
        """打印一条信息指出电瓶的续航里程"""
        if self.battery_size == 75:
            range = 260
        elif self.battery_size == 100:
            range = 315
        print(f"This car can go about {range} miles on a full charge.")
##############子类##################
class ElectricCar(Car):
    """电动汽车特点"""
    def __init__(self,make,model,year):
        """初始化Car父类属性，然后初始化电动车特有属性"""
        super().__init__(make, model, year)
        self.battery = Battery() # 调用电瓶属性

my_tesla = ElectricCar('tesla','model s',2020)
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()
```

- 方法 get_range() 做了一些简单的分析:

如果电瓶的容量为 75 kWh, 就将续航里程设置为 260 英里;如果容量为 100 kWh,就将续航里程设置为 315 英里, 然后报告这个值。

### 模拟实物--去解决实际问题，而不是一味钻研代码

模拟较复杂的物件(如电动汽车)时,需要解决一些有趣的问题。续航里程是电瓶的属性还是汽车的属性呢?如果只描述一辆汽车,将方法 get_range() 放在 Battery 类中也许是合适的,但如果要描述一家汽车制造商的整个产品线,也许应该将方法 get_range() 移到 ElectricCar 类中。在这种情况下,get_range() 依然根据电瓶容量来确定续航里程,但报告的是一款汽车的续航里程。也可以这样做:仍将方法 get_range() 留在 Battery 类中,但向它传递一个参数,如 car_model 。在这种情况下,方法 get_range() 将根据电瓶容量和汽车型号报告续航里程。

解决上述问题时,从较高的逻辑层面(而不是语法层面)考虑;考虑的不是 Python,而是如何使用代码来表示实物。达到这种境界后,你会经常发现,对现实世界的建模方法没有对错之分。有些方法的效率更高,但要找出效率最高的表示法,需要经过一定的实践。只要代码像你希望的那样运行,就说明你做得很好!即便发现自己不得不多次尝试使用不同的方法来重写类,也不必气馁。要编写出高效、准确的代码,都得经过这样的过程。

练习 9-6:冰激凌小店

冰激凌小店是一种特殊的餐馆。编写一个名为 IceCreamStand 的类,让它**继承为完成练习 9-1 或练习 9-4 而编写的 Restaurant 类**。这两个版本的 Restaurant 类都可以,挑选你更喜欢的那个即可。**添加一个名为 flavors 的属性**,用于存储一个由各种口味的冰激凌组成的列表。编写一个显示这些冰激凌的方法。创建一个**IceCreamStand**实例,并调用这个方法。

```python
class Restaurant:
    """一个表示餐馆的简单类"""
    def __init__(self, restaurant_name, cuisine_type):
        """"初始化属性restaurant_name 和cuisine_type"""
        self.restaurant_name = restaurant_name
        self.cuisine_type = cuisine_type

    def describe_restaurant(self):
        """打印餐馆的信息"""
        print(f"{self.restaurant_name.title()} is a {self.cuisine_type} restaurant.")

    def open_restaurant(self):
        """打印餐馆正在营业"""
        print(f"{self.restaurant_name.title()} is now open.")


class IceCreamStand(Restaurant):
    def __init__(self,restaurant_name, cuisine_type):
        super().__init__(restaurant_name, cuisine_type)
        self.flavors = flavors

    def show_flavors(self, flavors):
        print(f"{self.restaurant_name.title()} has the following flavors:")
        for flavor in self.flavors:
            print(f"- {flavor.title()}")

flavors = ['vanilla', 'chocolate', 'strawberry']
restaurant = IceCreamStand('ice cream stand', 'ice cream')
restaurant.show_flavors(flavors)

# restaurant_1 = Restaurant('pizza hut', 'pizza')
# restaurant_2 = Restaurant('taco bell', 'taco')
# restaurant_3 = Restaurant('burger king', 'burger')


# restaurant_1.describe_restaurant()
# restaurant_1.open_restaurant()
# restaurant_2.describe_restaurant()
# restaurant_2.open_restaurant()
# restaurant_3.describe_restaurant()
# restaurant_3.open_restaurant()
```

```python
class IceCreamStand:
    def __init__(self,stand_name,flavors):
        self.stand_name = stand_name
        self.flavors = flavors
    def show_flavors(self):
        print("The flavors are:")
        for flavor in self.flavors:
            print(flavor)

DQ = IceCreamStand("DQ",["vanilla","chocolate","strawberry"])
DQ.show_flavors()

```

练习 9-7:管理员

管理员是一种特殊的用户。**编写一个名为 Admin 的类**,让它继承为完成练习 9-3 或练习 9-5 而编写的 User 类。**添加一个名为 privileges 的属性,用于存储一个由字符串(如"can add post" 、"can delete post" 、"can ban user" 等)**组成的列表。编写一个名为 show_privileges() 的方法,显示管理员的权限。创建一个 Admin 实例, 并调用这个方法。

```python
class User():
    """一个表示用户的简单类"""
    def __init__(self, first_name, last_name, age, favorite_language):
        """"初始化属性first_name 和last_name"""
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
        self.favorite_language = favorite_language

    def describe_user(self):
        """打印用户信息摘要"""
        print(f"\nName: {self.first_name.title()} {self.last_name.title()},\nAge: {self.age}\nFavorite coding language: {self.favorite_language}")

    def greet_user(self):
        """向用户发出个性化的问候"""
        print(f"\nHello, {self.first_name.title()} {self.last_name.title()}!")

class Admin(User):
    def __init__(self,first_name,last_name,age,favorite_language):
        super().__init__(first_name,last_name,age,favorite_language)
        self.privileges = []
    def show_privileges(self,privileges):
        print("\nPrivileges:")
        for privilege in self.privileges:
            print(f"- {privilege}")


admin = Admin('admin','admin',20,'python')
privileges = ['can add post','can delete post','can ban user']
admin.show_privileges(privileges)
```

你写的有点问题，参考一下[这个](https://www.cnblogs.com/kevin-hou1991/p/14801305.html)：

```python
class User():   # 创建User类
    def __init__(self, first_name, last_name, age, address, phone): # 属性
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
        self.address = address
        self.phone = phone
        self.login_attempts = 0 # 添加属性

    def describe_user(self):    # 方法
        print(self.first_name,
              self.last_name,
              self.age,
              self.address,
              self.phone)

    def greet_user(self):   # 方法
        print("How beautiful name " + self.last_name + self.last_name,
              "\n too young, too simple", "your homeland " + self.address
              + " is a warm place, ", "could you tell me your contact?")

    def increment_login_attempts(self, number1):    # 递增方法
        self.login_attempts += number1  # 值加1
        print("共登录用户量：" + str(self.login_attempts))

    def reset_login_attempts(self, number2):    # 重置方法，重置为0
        self.login_attempts = 0
        print("共登录用户量：" + str(self.login_attempts))

# 创建Admin类
class Admin(User):
    # 初始化父类的属性，在初始化User特有的属性
    def __init__(self, first_name, last_name, age, address, phone):
        super().__init__(first_name, last_name, age, address, phone)
        self.privileges = []    #初始化特有属性

    def show_privileges(self): # 创建方法存储字符串
        for privilege in self.privileges:
            print(privilege)

admin = Admin('Kevin', 'Hou', 30, 'ShangHai', 13141516170)
admin.describe_user()
admin.privileges = ['can add post', 'can delete post', 'can ban user']
admin.show_privileges()
```

练习 9-8:权限

编写一个名为 Privileges 的类,它只有一个属性 privileges ,其中存储了练习 9-7 所述的字符串列表。将方法 show_privileges() 移到这个类中。在 Admin 类中,将一个 Privileges 实例用作其属性。创建一个 Admin 实例,并使用方法 show_privileges() 来显示其权限。

```python
class User:
    """初始化用户属性"""
    def __init__(self, first_name, last_name, age, profession,login_attempts):
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
        self.profession = profession
        """尝试添加登录次数属性"""
        self.login_attempts = login_attempts

        def describe_user(self):
            """描述用户信息的方法"""
            print(f"User information: {self.first_name.title()} {self.last_name.title()}, age: {self.age}, profession: {self.profession}")

        def greet_user(self):
            """问候方法"""
            print(f"Hello, {self.first_name.title()} {self.last_name.title()}!")

        def increment_login_attemnpts(self):
            """尝试登录次数增量方法"""
            self.login_attempts += 1
            print(f"{self.first_name.title()} {self.last_name.title()} has tried to login {self.login_attempts} times.")

        def reset_login_attempts(self):
            """重置登录次数"""
            self.login_attempts = 0
            print(f"{self.first_name.title()} {self.last_name.title()} has tried to login {self.login_attempts} times.")

class Privileges:
    """初始化权限属性"""
    def __init__(self, privileges=('can add post', 'can delete post', 'can ban user')):
        self.privileges = privileges

    def show_privileges(self):
        """显示权限的方法"""
        print("\nPrivileges:")
        for privilege in self.privileges:
            print(f"- {privilege}")


class Admin(User):
    """初始化管理员子类的属性"""
    def __init__(self, first_name, last_name, age, profession,login_attempts):
        super().__init__(first_name, last_name, age, profession,login_attempts)
        self.privileges = Privileges()

admin = Admin('kevin', 'hou', 30, 'ee', 1)
admin.privileges.show_privileges()
```

练习 9-9:电瓶升级

在本节最后一个 electric_car.py 版本中,给 Battery 类添加一个名为 upgrade_battery() 的方法。该方法检查电瓶容量,如果不是 100,就将其设置为 100。创建一辆电瓶容量为默认值的电动汽车,调用方法 get_range() ,然后对电瓶进行升级,并再次调用 get_range() 。你将看到这辆汽车的续航里程增加了。

```python
##############父类##################
class Car:
    """一次模拟汽车的简单尝试"""
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        print(f"This car has {self.odometer_reading} miles on it")

    def update_odometer(self, mileage):
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

    def increment_odometer(self, miles):
        self.odometer_reading += miles
##############电瓶类，并添加一个新方法显示电池续航里程##################
class Battery:
    """一次模拟电动汽车电瓶的方法"""
    def __init__(self, battery_size=75):
        """初始化电瓶属性"""
        self.battery_size = battery_size

    def describe_battery(self):
        """打印一条描述电瓶容量的消息"""
        print(f"This car has a {self.battery_size} - kWH battery.")

    def get_range(self):
        """打印一条信息指出电瓶的续航里程"""
        if self.battery_size == 75:
            range = 260
        elif self.battery_size == 100:
            range = 315
        print(f"This car can go about {range} miles on a full charge.")

    def upgrade_battery(self):
        """将电瓶容量设置为100"""
        if self.battery_size != 100:
            self.battery_size = 100
            print(f"Upgraded battery range to {self.battery_size} - kWH")
        else:
            print(f"Battery range is already at {self.battery_size} - kWH")

##############子类##################
class ElectricCar(Car):
    """电动汽车特点"""
    def __init__(self,make,model,year):
        """初始化Car父类属性，然后初始化电动车特有属性"""
        super().__init__(make, model, year)
        self.battery = Battery() # 调用电瓶属性

my_tesla = ElectricCar('tesla','model s',2020)
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()
my_tesla.battery.upgrade_battery()
```

## Basic customization

### repr

### main

## 导入类

将类存储在模块中,然后在主程序中导入所需的模块，**使得文件尽可能整洁**

明确起心动念，堪比写文章

### 导入单个类

下面来创建一个只包含 Car 类的模块。

这让我们面临一个微妙的命名问题:在本章中已经有一个名为 car.py 的文件,但这个模块也应命名为 car.py,因为它包含表示汽车的代码。

我们将这样解决这个命名问题:将 Car 类存储在一个名为 car.py 的模块中,该模块将覆盖前面使用的文件 car.py。

从现在开始,使用该模块的程序都必须使用更具体的文件名,如 my_car.py。

```python
class Car:
    """模拟汽车的简单尝试"""
    def __init__(self,make,model,year):
        """初始化描述汽车的属性"""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        """返回整洁的汽车描述性信息"""
        long_name = f"{self.year} {self.make} {self.model}"
        return long_name.title()

    def read_odometer(self):
        """打印一条指出汽车里程的消息"""
        print(f"This car has {self.odometer_reading} miles on it.")

    def update_odometer(self, mileage):
        """将里程表读数设为定植值，拒绝回调"""
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can not roll back the odometer.")

        def increment_odometer(self,miles):
            """将里程表读书增加指定的量"""
            self.odometer_reading += miles
```

import 语句让 Python 打开模块 car 并导入其中的 Car 类。这样,我们就可以使用 Car 类,就像它是在这个文件中定义的一样。输出与我们在前面看到的一样

```python
from car import Car

my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())
```

### 在一个模块中存储多个类

Battery 类和 ElectricCar 类都可帮助模拟汽车,下面将它们都加入模块 car.py 中

```python
from car import ElectricCar

my_tesla = ElectricCar('tesla', 'model s', 2019)

print(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()
```

### 从一个模块中导入多个类

```python
from car import Car, ElectricCar

my_beetle = Car('volkswagen', 'beetle', 2019)
my_tesla = ElectricCar('tesla', 'roadster', 2019)

print(my_beetle.get_descriptive_name())
print(my_tesla.get_descriptive_name())
```

### 导入整个模块

```python
import car

my_beetle = car.Car('volkswagen', 'beetle', 2019)
my_tesla = car.ElectricCar('tesla', 'roadster', 2019)

print(my_beetle.get_descriptive_name())
print(my_tesla.get_descriptive_name())
```

### 导入模块中的所有类——不推荐

不推荐使用这种导入方式:

1. 如果只看文件开头的 import 语句, 就能清楚地知道程序使用了哪些类,将大有裨益。然而这种导入方式没有明确地指出使用了模块中的哪些类。
2. 第二,这种方式还可能引发名称方面的迷惑。如果不小心导入了一个与程序文件中其他东西同名的类,将引发难以诊断的错误。这里之所以介绍这种导入方式,是因为虽然不推荐使用,但你可能在别人编写的代码中见到它。

### 在一个模块中导入另一个模块

将类分散到多个模块中,可以避免模块太大或在同一个模块中存储不相关的类。

将类存储在多个模块中时,你可能会发现一个模块中的类依赖于另一个模块中的类。

在这种情况下,可在前一个模块中导入必要的类。

下面将 Car 类存储在一个模块中,并将 ElectricCar 类和 Battery 类存储在另一个模块中。将第二个模块命名为 electric_car.py(这将覆盖前面创建的文件 electric_car.py),并将 Battery 类和 ElectricCar 类复制到这个模块中

```python
"""一组可用于表示电动汽车的类。"""
 ❶ from car import Car

 class Battery:
     --snip
class ElectricCar(Car):
    --snip--

```

存储为 electric_car.py

```python
from car import Car

from electric_car import ElectricCa

my_beetle = car.Car('volkswagen', 'beetle', 2019)
my_tesla = car.ElectricCar('tesla', 'roadster', 2019)

print(my_beetle.get_descriptive_name())
print(my_tesla.get_descriptive_name())
```

换汤不换药，重在理解

### 使用别名

```python
import pandas as pd
```

### 自定义工作流程

在组织大型项目的代码方面,Python 提供了很多选项。

熟悉所有这些选项很重要,这样你才能确定哪种项目组织方式是最佳的,并能理解别人开发的项目。

**一开始应让代码结构尽可能简单**。先尽可能在一个文件中完成所有的工作,**确定一切都能正确运行后,再将类移到独立的模块中**。

如果你喜欢模块和文件的交互方式,可在项目开始时就尝试将类存储到模块中。先找出让你能够编写出可行代码的方式,再尝试改进代码。

动手试一试练习 9-10:导入 Restaurant 类 将最新的 Restaurant 类存储在一个模块中。在另一个文件中,导入 Restaurant 类,创建一个 Restaurant 实例并调用 Restaurant 的一个方法,以确认 import 语句正确无误。
练习 9-11:导入 Admin 类 以为完成练习 9-8 而做的工作为基础。将 User 类、Privileges 类和 Admin 类存储在一个模块中,再创建一个文件,在其中创建一个 Admin 实例并对其调用方法 show_privileges() ,以确认一切都能正确运行。
练习 9-12:多个模块 将 User 类存储在一个模块中,并将 Privileges 类和 Admin 类存储在另一个模块中。再创建一个文件,在其中创建一个 Admin 实例并对其调用方法 show_privileges() ,以确认一切依然能够正确运行。

## Python 标准库

**Python 标准库**是一组模块,我们安装的 Python 都包含它。

你现在对函数和类的工作原理已有大致的了解,可以开始使用其他程序员编写好的模块了。

可以使用标准库中的任何函数和类,只需在程序开头包含一条简单的 import 语句即可。

下面来看看模块 random ,它在你模拟很多现实情况时很有用。

```python
from random import randint

a = randint(1,6)

print(a)
```

在模块 random 中,另一个有用的函数是 choice() 。它将一个列表或元组作为参数,并随机返回其中的一个元素

```python
from random import choice
players = ['charles', 'martina', 'michael', 'florence', 'eli']
first_up = choice(players)
print(first_up)
```

练习 9-13:骰子 创建一个 Die 类,它包含一个名为 sides 的属性,该属性的默认值为 6。编写一个名为 roll_die() 的方法,它打印位于 1 和骰子面数之间的随机数。创建一个 6 面的骰子再掷 10 次。
创建一个 10 面的骰子和一个 20 面的骰子,再分别掷 10 次。
练习 9-14:彩票 创建一个列表或元组,其中包含 10 个数和 5 个字母。从这个列表或元组中随机选择 4 个数或字母,并打印一条消息,指出只要彩票上是这 4 个数或字母,就中大奖了。
练习 9-15:彩票分析 可以使用一个循环来明白前述彩票大奖有多难中奖。为此,创建一个名为 my_ticket 的列表或元组,再编写一个循环,不断地随机选择数或字母,直到中大奖为止。请打印一条消息,报告执行循环多少次才中了大奖。
练习 9-16:Python Module of the Week 要了解 Python 标准库,一个很不错的资源是网站 Python Module of the Week。请访问该网站并查看其中的目录, 找一个你感兴趣的模块进行探索。从模块 random 开始可能是个不错的选择。

## 类编码风格

你必须熟悉有些与类相关的编码风格问题,在编写的程序较复杂时尤其如此:

- 类名应采用**驼峰**命名法 ,即将类名中的每个单词的首字母都大写,而不使用下划线。实例名和模块名都采用小写格式,并在单词之间加上下划线。
- 对于每个类,都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能,并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串,对其中的类可用于做什么进行描述。
- 可使用空行来组织代码,但不要滥用。在类中,可使用一个空行来分隔方法;而在模块中,可使用两个空行来分隔类。
- 需要同时导入标准库中的模块和你编写的模块时,先编写导入标准库模块的 import 语句,再添加一个空行,然后编写导入你自己编写的模块的 import 语句。
- 在包含多条 import 语句的程序中,这种做法让人更容易明白程序使用的各个模块都来自何处。

## 小结

在本章中,你学习了:如何编写类;如何使用属性在类中存储信息,以及如何编写方法,以让类具备所需的行为;如何编写方法**init**() ,以便根据类创建包含所需属性的实例。你见识了如何修改实例的属性,包括直接修改以及通过方法进行修改。你还了解了使用继承可简化相关类的创建工作,以及将一个类的实例用作另一个类的属性可让类更简洁。

你了解到,通过将类存储在模块中,并在需要使用这些类的文件中导入它们,可让项目组织有序。你学习了 Python 标准库,并见识了一个使用模块 random 的示例。
最后,你学习了编写类时应遵循的 Python 约定
